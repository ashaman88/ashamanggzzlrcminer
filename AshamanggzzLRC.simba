///////////////////////////////////////////////////////////////////////
//                                                                   //
//          READ THE DIRECTIONS IN THE OP FIRST OR ELSE              //
//           Make sure you have setup your player file               //
//                  Under SRL>PlayerManager                          //
//                       Press Play                                  //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
//                                                                                       //
//           Don't touch below this line unless you know what you're doing!!             //
//                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////
Program AshamanggzzLRC;
  {$IFDEF RAYMONDPOWNS}{wrappers} function FloodFillTPAWrap(const TPA: TPointArray): T2DPointArray; var tempATPA: T2DPointArray; begin tempATPA:= FloodFillTPA(TPA); Result:= tempATPA; SetLength(tempATPA, 0); end; function FindTPAEdges(const p: TPointArray): TPointArray; begin FindTPAEdgesWrap(p, result); end; Function RotatePoints(Const P: TPointArray; A, cx, cy: Extended): TPointArray; begin RotatePointsWrap(P, A, cx, cy, result); end; function TPAFromCircle(const CX, CY, Radius: Integer): TPointArray; begin TPAFromCircleWrap(CX, CY, Radius, result); end; function TPAFromEllipse(const CX, CY, XRadius, YRadius : Integer): TPointArray; begin TPAFromEllipseWrap(CX, CY, XRadius, YRadius, result); end; function TPAFromBox(const Box : TBox) : TPointArray; begin TPAFromBoxWrap(Box, result); end; Function ReturnPointsNotInTPA(Const TotalTPA: TPointArray; const Box: TBox): TPointArray; begin ReturnPointsNotInTPAWrap(TotalTPA, Box, result); end; function CombineIntArray(const Ar1, Ar2: TIntegerArray): TIntegerArray; begin CombineIntArrayWrap(Ar1, Ar2, result); end; function ReArrangeandShortenArray(const a: TPointArray; Dist: Integer): TPointArray; begin ReArrangeandShortenArrayWrap(a, Dist, result); end; function ReArrangeandShortenArrayEx(const a: TPointArray; w, h: Integer): TPointArray; begin ReArrangeandShortenArrayExWrap(a, w, h, result); end; function CombineTPA(const Ar1, Ar2: TPointArray): TPointArray; begin CombineTPAWrap(Ar1, Ar2, Result); end; function RemoveDistTPointArray(x, y, dist: Integer;const ThePoints: TPointArray; RemoveHigher: Boolean): TPointArray; begin RemoveDistTPointArrayWrap(x, y, dist, ThePoints, RemoveHigher, Result); end; function TPAFromText(const text, font: String; var w,h: Integer): TPointArray; begin TPAFromTextWrap(text, font, w, h, result); end; function GetColors(const Coords: TPointArray): TIntegerArray; begin GetColorsWrap(Coords, Result); end; function Explode(del, str: string): TStringArray; begin ExplodeWrap(del, str, Result); end; function MergeATPA(const ATPA : T2DPointArray): TPointArray; begin MergeATPAWrap(ATPA, Result); end; function SplitTPA(arr : TPointArray; dist : Integer) : T2DPointArray; begin SplitTPAWrap(arr, dist, result); end; function SplitTPAEx(arr : TPointArray; w, h : integer) : T2DPointArray; begin SplitTPAExWrap(Arr, w, h, result); end; function ClearTPAFromTPA(arP, ClearPoints : TPointArray) : TPointArray; begin ClearTPAFromTPAWrap(arP, ClearPoints, result); end; function TPAToATPAEx(arP : TPointArray; w, h : integer) : T2DPointArray; begin TPAtoATPAExWrap(arP, w, h, result); end; function TPAToATPA(arP : TPointArray; dist : Integer) : T2DPointArray; begin TPAtoATPAWrap(arP, dist, result); end; function FindGapsTPA(TPA : TPointArray; MinPixels : integer) : T2DPointArray; begin FindGapsTPAWrap(tpa, MinPixels, result); end; {$ENDIF}
  {$Define SMART}
  {$I SRL-6/SRL.Simba}
  {$i srl-6/lib/misc/srlplayerform.simba}
  {$I SPS/lib/SPS-RS3.Simba}

Var
  PTS: Integer;
  Method,BreakIn,BreakFor: Integer;
  SFS,JIC,TakeBreaks,ActionBars: Boolean;
  SuperHeatKey,Alch,GoldOre,GoldBar,CoalOre: String;
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                  Begin of user setup                              //
//                Fill in the fields below                           //
//                                                                   //
///////////////////////////////////////////////////////////////////////


Const
  DMP = True;                     // ***If the SPS Maps aren't found, Download them and save them automatically, you should leave this as true***
  Timeouts = True;                // ***Do you want script to shutdown if nothing has happened for several minutes?***
  Bir          = 13;              // ***Random minutes to add/subtract from how long until we break***
  Bfr          = 7;               // ***Random minutes to add/subjtract from break duraction***
  ScriptVersion = '8.07';
  E = 200;
  F = 462;
  Debug = False;
  POSDebug = False;
  AnimationDebug = False;

procedure declarePlayers();
var
  i,j: integer;
begin
  players.setup(playerForm.playerNames, playerForm.playerFile); // load the SPF players from the SRL Player Manager
  currentPlayer := 0;                                           // player to use first

  // set player attributes based on the settings from the form
  for i := 0 to high(players) do
    with players[i] do
    begin
      SuperHeatKey := playerForm.players[i].settings[0];
      Alch := playerForm.players[i].settings[1];
      GoldOre  := playerForm.players[i].settings[2];
      GoldBar  := playerForm.players[i].settings[3];
      CoalOre  := playerForm.players[i].settings[4];
      BreakIn := strToInt(playerForm.players[i].settings[5]);  //minutes until break
      BreakFor := strToInt(playerForm.players[i].settings[6]);  //minutes to break


      TakeBreaks := strToBool(playerForm.players[i].settings[7]);
      ActionBars := strToBool(playerForm.players[i].settings[8]);
      SFS := strToBool(playerForm.players[i].settings[9]);
      JIC := strToBool(playerForm.players[i].settings[10]);
      FindMod := strToBool(playerForm.players[i].settings[11]);



      for j := 0 to high(playerForm.comboBoxItems[0]) do
        if (playerForm.players[i].settings[12] = playerForm.comboBoxItems[0][j]) then
          Method := j;

      World :=  84;                    //world

      strings[0] := playerForm.players[i].settings[13]; //graphics
    end;
end;

// initiates the SRL player form (you aren't restricted to the procedure name; it can be whatever you want)
procedure initPlayerForm();
begin
  with playerForm do
  begin
    name := 'AshamanLRC v'+toStr(ScriptVersion); // the title of the SPF, usually the name of your script
    scriptHelpThread := '';           // a link to a help thread, if set to '' will link to my setup guide
    scriptSettingsPath := '';         // where you want the settings file to be saved; saved in script's path by default

    editBoxLabels := ['SuperheatKey', 'AlchKey', 'GoldOreKey', 'GoldBarKey', 'CoalOreKey', 'Minutes until Break', '# of Minutes to Break']; // edit boxes are created for each array element
    editBoxDefaults := [ '0', '1', '2', '3', '4', '600', '15'];                                             // optional default values for each edit box; array length must equal editBoxLabel length
    checkBoxLabels := ['Take Breaks', 'Use ActionBar', 'MagicStaff', 'RuneFailsafe', 'Logout if Mod is near'];        // same as editBoxLabels but for check boxes
    checkBoxDefaults := ['True','True','True','True','False'];

    comboBoxLabels := ['Method', 'GraphicsMode'];                                                // same as editBoxLabels but for combo boxes (drop down boxes)
    comboBoxDefaults := ['Bank','OpenGL'];

    // this needs to be done for every element in the comboBoxLabels array
    setLength(comboBoxItems, length(comboBoxLabels));
    comboBoxItems[0] := ['Bank', 'Drop', 'Alch','SuperheatBank', 'SuperheatDrop'];       // all the options available for the first combo box
    comboBoxItems[1] := ['OpenGL', 'DirectX'];
  end;
end;


///////////////////////////////////////////////////////////////////////////////////////////
//                                                                                       //
//                            End of user setup                                          //
//           Don't touch below this line unless you know what you're doing!!             //
//                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////




Var
 Spot,SpotDTM,A,B,C,D,GoldX,GoldY,SummoningTimer,M,NewPouch: Integer;
 W,X,Y,Z,RealBTime,BreakRounds,TotalBreaks: Integer;
 OreCount,XP,OneOre,BarDTM,Staff,EmptySpot,GoldDTM,CoalDTM: Integer;
 CurrentBTime,Timeout,Timeout2,CoalTimer: TTimeMarker;
 StartingExperience, XPH,OresPH,HP,OldHP: Extended;
 HeatAlch,SafeBank,NoFamiliar: Boolean;
 Off,FunctionStop: String;

 {*******************************************************************************
Function AutoupdateMe;
By: Shuttleu
Edited By: Ashaman88
Description: Autoupdates Script.
*******************************************************************************}
Procedure AutoUpdateMe;
Var
  Neifile: Integer;
  OnlineVersion, NewScript, NeiFeilNennen: String;
Begin
  Writeln('Checking for script updates...');
  OnlineVersion := GetPage('http://ashamanggzzlrcminer.googlecode.com/git/Version.txt');
  Writeln('Online Version: '+ToStr(OnlineVersion));
  Writeln('Local Version: '+ToStr(ScriptVersion));
  If (trim(OnlineVersion) > ScriptVersion) Then
  Begin
    WriteLn('Newer script version online!');
    WriteLn('Autoupdating to newer version.');
    NewScript := GetPage('http://ashamanggzzlrcminer.googlecode.com/git/AshamanggzzLRC.simba');
    NeiFeilNennen := ScriptPath+ 'LRC Miner V'+OnlineVersion+' by A&B.simba';
    Neifile := Rewritefile(NeiFeilNennen, true);
    Try
      WriteFileString(Neifile, NewScript);
    Except
      Begin
        WriteLn('Fatal error writing to '+NeiFeilNennen+'!!');
        Terminatescript;
      End;
    End;
    CloseFile(Neifile);
    WriteLn('New script downloaded to '+NeiFeilNennen+'!! Please use this one!!');
    TerminateScript;
  End Else
    WriteLn('You have the latest version of the script!');
End;

Function FindNormalRandoms: Boolean;
Begin
  Result:= ExitSquealOfFortune Or ClaimSpinTicket;
End;

Procedure SetDTM;
Begin
  Writeln('Loading viruses...I mean DTMs');

  W := (BreakIn * 60000);
  X := (BreakFor * 60000);
  Y := RandomRange(-BIR * 60000, BIR * 60000);
  Z := RandomRange(-BFR * 60000, BFR * 60000);

  GoldDTM := DTMFromString('mWAAAAHicY2FgYJjBxMDQB8SzgHgxEAcyMjAEAbEHEHsD8eZ+KYZEPzOGTb2SDJkh1gz8QD3ImBENgwAA4fkIew==');
  BarDTM:= DTMFromString('mbQAAAHicY2VgYJjPxMCwBIgXA/FsIF4FxAqMDAzyQKwCxKpArAjEC+rFGC4tlwXjSHcehhur5Rj4gfrRMSMWDAYA8jMK5w==');
  CoalDTM := DTMFromString('mggAAAHicY2NgYMhjYmAoAuIkIM4C4gogLgHiJ0C52wwQ+g0QPwTiF0Csri4HxuGuBgzRnsYMWSHWDJKSwgz8QDlsmBEHhgAAKPUMHA==');
  Staff := DTMFromString('mWAAAAHicY2FgYJjKxMDQBcQzgXgBELcyMjBMBOIGIK4AYmVpaQYTZWUGSWFhhk8zeRjkgHqQMRMaBgEAu6MHoA==');
End;

Procedure F33DTM;
Begin
  FreeDTM(GoldDTM);
  FreeDTM(BarDTM);
  FreeDTM(CoalDTM);
  FreeDTM(Staff);
  If DTMExists(SpotDTM) Then
    FreeDTM(SpotDTM);
End;

Function BreakHandler(BreakIn, BreakFor, randBreakIn, randBreakFor: Integer): Boolean;
Var
  H,M,S: Integer;
Begin
  FUNCTIONSTOP:='BREAK ENTERED';

  If Not IsLoggedIn Then
    Exit;

  If (GetTimeRunning < ((W) + (Y) + BreakRounds)) Then
    Exit Else
    If (GetTimeRunning > ((W) + (Y) + BreakRounds)) Then
    Begin
      RealBTime := Round((X+Z)/60000);
      Writeln('Taking a break for about ' + IntToStr(RealBTime) + ' minutes.');
      Players[CurrentPlayer].Logout;
      CurrentBTime.Reset;
      CurrentBTime.Start;
      Repeat
        Wait(21000);
        ConvertTime((X+Z)-CurrentBTime.GetTime,H,M,S);
        Writeln('Breaktime left: '+IntToStr(H)+':'+IntToStr(M)+':'+IntToStr(S));
      Until(CurrentBTime.GetTime>(X+Z));
      Writeln('Logging in.');
      Players[CurrentPlayer].Login;
      Wait(4000);
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
      Result := IsLoggedIn;
      Minimap.ClickCompass;
      MainScreen.SetAngle(MS_ANGLE_HIGH);
      IncEx(BreakRounds, (W) + (X));
      Inc(TotalBreaks);
      Writeln('The next break will occur in about ' + IntToStr(BreakIn) + ' minutes.');
      W := (BreakIn * 60000);
      X := (BreakFor * 60000);
      Y := RandomRange(-BIR * 60000, BIR * 60000);
      Z := RandomRange(-BFR * 60000, BFR * 60000);
    End;
  FUNCTIONSTOP:='BREAK EXIT';
End;

Function HPPercent: Integer;
Var
  CTS: Integer;
Begin
  If Not IsLoggedIn Then
    Exit;

  result:= actionBar.getHPPercent;
End;

Function SetRest: Boolean;
Var
  T: TTimeMarker;
Begin
  Result:=Minimap.IsResting;
  If Result Then
    Exit;

  MouseBox(IntToBox(768,29,786,46),Mouse_Right,Mouse_Human);
  ChooseOption.Select(['Rest','est'],RandomRange(700,900));

  T.Start;
  While Not Result Do
  Begin
    Result:=Minimap.IsResting;
    If T.GetTime > 5000 Then
      Break;
  End;
End;

Function RunPercent: Integer;
Var
  CTS,Count: Integer;
Begin
  If Not IsLoggedIn Then
    Exit;

  CTS := GetToleranceSpeed;
  SetColorToleranceSpeed(2);                      //100      75       50        25         0
                                                  //429     383      302       263       149
  SetToleranceSpeed2Modifiers(0.25,1.76);
  Count:= CountColorTolerance(3504305,IntToBox(766,24,786,48),25);
  SetColorToleranceSpeed(CTS);
  SetToleranceSpeed2Modifiers(0.2,0.2);

  If Count >= 428 Then
  Begin
    Result:= 100;
    Exit;
  End;

  If Count <= 150 Then
  Begin
    Result:= 0;
    Exit;
  End;

  Result:=Round((0.0005 * (count * count)) + (0.0549 * count) - 17.599);
End;

Function Antiban: Boolean;
Var
  I: Integer;
Begin
  I := Random(600);
  Case I Of
    1: boredHuman(false);
    2..7:
      Begin
        hoverSkill(Skill_Mining);
        Wait(GaussRangeInt(1000,2000));
      End;
    8..50: mouseMovingObject;
    51..100: SleepAndMoveMouse(RandomRange(100,6000));
    101..400:
      Begin
        MouseOffClient(Random(4));
        Wait(RandomRange(2000, 15000));
      End;
    501..600: Wait(RandomRange(1000, 2000));

  End;
  If (TabBackpack.Count<25) And ((HPPercent > (75))) Then
    Wait(GaussRangeInt(3000,4000));
End;

function TRSChatBox.getXP: Integer;
var
  b: TBox;
  s: String;
  tpa : TPointArray;
  atpa : T2DPointArray;
  i,cts,p: Integer;
begin
  b := self.getBounds();
  b.edit(+(b.x2-b.x1)-140, +10, -5, -94);

  findColorsTolerance(tpa, 14013909, b, 4,colorSetting(2, 0.00, 0.00));

  if length(tpa) < 2 then
  begin
    print('chatBox.getXP(): No XP found', TDebug.SUB);
    Exit;
  end;

  atpa := tpa.cluster(5);

  b:= atpa.getbounds;
  b.edit(-2,-2,+2,+3);

  s:=Replace(tesseractgettext(b.x1,b.y1,b.x2,b.y2, FILTER_SMALL_CHARS), ' ', '', [rfReplaceAll]);

  P := Pos('x', S);
  if P > 0 then
    Result := StrToIntDef(ExtractFromStr(Copy(s, P, Length(S)), Numbers), 0)
  else
    Result := StrToIntDef(ExtractFromStr(S, Numbers), 0);

  print('chatBox.getXP(): XP found: ' + tostr(result), TDebug.SUB);
end;

Procedure ProgressReport;
Var
  TTB: Integer;
Begin
  If (Not Debug) And (Not AnimationDebug) And (Not POSDebug) Then
    ClearDebug;

  TTB := (((W) + (Y) + BreakRounds)-GetTimeRunning);

  OreCount := OreCount + TabBackpack.CountDTM(GoldDTM)+TabBackpack.CountDTM(CoalDTM);
  XP := (ChatBox.GetXP - Round(StartingExperience));
  XPH := Round(XP * (3600.0 / (GetTimeRunning / 1000.0)));
  OresPH := Round((OreCount * (3600.0 / (GetTimeRunning / 1000.0))));

  writeln('|=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=|');
  writeln('|                     AshamanLRC v'+PadR(toStr(ScriptVersion), 26), '|');
  writeln('|=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=|');
  writeln(PadR('| Running For: '+TimeRunning, 60)+'|');
  writeln(PadR('| Ore''s Burned: ' + GroupDigits(OreCount,','), 40) + padR('Ores/H: ' + GroupDigits(OresPH,','), 20) + '|');
  writeln(PadR('| Exp Earned: ' + GroupDigits(XP,','), 40) + padR('Exp/Hour: ' + GroupDigits(XPH,','), 20) + '|');
  writeln('|___________________________________________________________|');
  writeln('|___________________________________________________________|');

  If TakeBreaks Then
    Writeln('Time until break: '+MsToTime(TTB, Time_Bare));
End;

Function ToBank: Boolean; Forward;

Function CheckStuff: Boolean;
Begin
  Result:=False;

  If Not IsLoggedIn Then
  Begin
    DisableSRLDebug:=False;
    Wait(RandomRange(4000,6000));
    If Not Players[CurrentPlayer].Login Then
      TerminateScript;
    Wait(RandomRange(4000,6000));
    If Not Debug Then
      DisableSRLDebug:=True;
    Minimap.ClickCompass;
    MainScreen.SetAngle(MS_ANGLE_HIGH);
    FindNormalRandoms;
    Timeout.Reset;
    Timeout.Start;
    Timeout2.Reset;
    Timeout2.Start;
    Result:=True;
  End;

  If Timeout.GetTime>120000 Then
  Begin
    Writeln('Nothing has happened for too long, resetting focus.');
    Timeout.Reset;
    Timeout.Start;
    Minimap.ClickCompass;
    MainScreen.SetAngle(MS_ANGLE_HIGH);
    FindNormalRandoms;
    If Not ToBank Then
    Begin
      Writeln('Did not get to bank, logging in and out to reset map');
      Players[CurrentPlayer].ExitToLobby;
      Wait(RandomRange(2500,3500));

      If Debug Then
        Writeln('Loging back in');

      Players[CurrentPlayer].Login;
      Wait(RandomRange(2000,3000));
      Minimap.ClickCompass;
      MainScreen.SetAngle(MS_ANGLE_HIGH);
      FindNormalRandoms;
      ToBank;
    End;
  End;

  If Timeouts Then
    If Timeout2.GetTime>300000 Then
    Begin
      Writeln('Nothing has happened for too long, shutting down.');
      Players[CurrentPlayer].Logout;
      TerminateScript;
    End;

  If FindNormalRandoms Then
    If Not IsLoggedIn Then
      TerminateScript Else
      Begin
        Minimap.ClickCompass;
        MainScreen.SetAngle(MS_ANGLE_HIGH);
        If Debug Then
          Writeln('Found squeal stuff');
        Result:=True;
      End;
End;

Function AtBank: Boolean;
Var
  BankBox: TBox;
Begin
  BankBox:=IntToBox(100,65,125,80);
  If Not PointInBox(SPS.GetPlayerPos,BankBox) Then
  Begin
    If Debug Then
    Begin
      Writeln('Not at bank');
      Writeln('bank coordinates: '+Off);
    End;
  End Else
    Result:=True;
End;

Function LRCPaths(Which: Integer; Invert: Boolean): TPointArray;
Var
  BankToLowestGold,BankToHighGold,LowToHighGold,LowGoldToCoal: TPointArray;
  Paths: T2DPointArray;
Begin
  If Debug Then
    FunctionStop:= 'LRCPATHS: Entered';

  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  BankToLowestGold:= [Point(198,226), Point(210,238), Point(210,258), Point(214,286), Point(226,314), Point(242,338), Point(257,369)];

  BankToHighGold:= [Point(198,226), Point(210,270), Point(174,290), Point(142,294)];

  LowToHighGold:= [Point(257,369), Point(218,318), Point(170,306), Point(142,294)];

  LowGoldToCoal:= [Point(257,369), Point(242,338), Point(234,314), Point(238,302)];

  Paths:= [BankToLowestGold, BankToHighGold, LowToHighGold, LowGoldToCoal];

  Case Which of
    1: Result:= Paths[0];
    2: Result:= Paths[1];
    3: Result:= Paths[2];
    4: Result:= Paths[3];
  End;

  If Invert Then
  Begin
    InvertTPA(Result);
  End;

  If Debug Then
    FunctionStop:= 'LRCPATHS: Finished';
End;

Function Runaways: Boolean;
Var
  FailRest: Integer;
  T: TTimeMarker;
Begin
  If Debug Then
    FunctionStop:= 'Runaways: Entered';

  Result:=False;
  CheckStuff;
  If Not IsLoggedIn Then
    Exit;

  If OldHP <= HPPercent Then
  Begin
    If Debug Then
      Writeln('Gained some HP');
    If OldHP <> -1 Then
    Begin
      If Debug Then
        Writeln('Old HP level: '+ToStr(OldHP));
      OldHP:=HPPercent;
      If Debug Then
        Writeln('New HP level: '+ToStr(OldHP));
      Exit;
    End;
  End Else
    If Debug Then
      Writeln('Lost some HP');

  If Debug Then
    Writeln('Old HP level: '+ToStr(OldHP));
  OldHP:=HPPercent;
  If Debug Then
    Writeln('New HP level: '+ToStr(OldHP));

  If ((HPPercent < (80))) Then
  Begin
    If HPPercent=-1 Then
      Exit;
    OldHP:=HPPercent;
    Writeln('HP LOW '+ToStr(HPPercent)+' RUNNING AWAY');

    Writeln('HP Threshold '+ToStr((80)));

    If (Spot = 1) Or (Spot = 3) Then
    Begin
      If Debug Then
        Writeln('Running from low spots');
      If Not SPS.WalkPath(LRCPaths(1, True)) Then
        Exit;
    End Else
    Begin
      If Debug Then
        Writeln('Running from high spot');
      If Not SPS.WalkPath(LRCPaths(2, True)) Then
        Exit;
    End;

    T.Start;
    Repeat
      Wait(Random(1000));
      If (T.GetTime>6000) Or (Not IsLoggedIn) Then
        Break;
    Until Not Minimap.IsPlayerMoving;

    If Debug Then
      Writeln('Checking if Monster is still there');

    If Not AtBank Then
      If (Spot = 1) Or (Spot = 3) Then
      Begin
        If Debug Then
          Writeln('Running from low spots');
        SPS.WalkPath(LRCPaths(1, True));
      End Else
      Begin
        If Debug Then
          Writeln('Running from high spot');
        SPS.WalkPath(LRCPaths(2, True));
      End;

    Result := True;

    Wait(RandomRange(5000,6000));

    If RunPercent < 50 Then
    Begin
      If Debug Then
        Writeln('Low energy resting');
      Setrest;
      Repeat
        Timeout.Reset;
        Timeout.Start;
        Timeout2.Reset;
        Timeout2.Start;
        Wait(100);
        CheckStuff;
        If Not IsLoggedIn Then
          Exit;
        If Not SetRest Then
          Inc(FailRest);
        If FailRest>5 Then
          Exit;
      Until RunPercent >= 90;
      Minimap.ToggleRun(True);
    End;

    If (HPPercent > (69)) Then
    Begin
      Writeln('HP IS '+ToStr(HPPercent));
      Writeln('HP > Wait Threshold of '+ToStr((69)));
      Exit;
    End;

    SetRest;

    If Debug Then
        Writeln('Waiting to heal');

    Repeat
      Wait(RandomRange(20000,40000));
      SmallRandomMouse;
      CheckStuff;
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
      If Not IsLoggedIn Then
        Break;
    Until((HPPercent > (69)));

    If Debug Then
      Writeln('All healed');
  End;
  If Debug Then
    FunctionStop:= 'Runaways: finished';
End;

Procedure Moving;
Var
  T: TTimeMarker;
Begin
  T.Start;
  Repeat
    CheckStuff;
    If Runaways Then
      Exit;
    If (Not Minimap.IsFlagPresent) And (Minimap.IsPlayerMoving) Then
      Wait(RandomRange(1400,1700));
    If Not Minimap.IsFlagPresent Then
      Break;
    If Not IsLoggedIn Then
      Break;
  Until ((Not(Minimap.IsPlayerMoving)) Or (T.GetTime > 12000));
End;

Function LowGold: Integer;
Var
  CTS,Count: Integer;
Begin
  If Not IsLoggedIn Then
    Exit;                        //1400
  Result:= CountColorTolerance(4088954,IntToBox(210,210,274,256),8,colorSetting(2,0.07,0.20));
End;

Function GoldDTMs: Boolean;
Var
  I: Integer;
  T: TTimeMarker;
Begin
  Result:=False;

  T.Start;
  For I:=0 To 1 Do
  Begin
    Case Spot Of
      1:
      Begin
        If LowGold> 420 Then
        Begin
          Result:=True;
          GoldX:=246;
          GoldY:=204;
        End;
        Exit;
      End;
      2:
      Begin
        A:=105;  B:=44;   C:=380;  D:=300;
        Case I Of
          0: SpotDTM := DTMFromString('m6wAAAHic42ZgYEgD4kAgjgTiFCBOBeJSIM4HYl8gzgHiaiAuAGJ7IPYG4mAg9gRiYyi2BGIzKNsKiPWBuDjOkqEi2YahPdeFoTXbGUynh5owuJhJMzRlOjG05jgz1KbaM/jYyDHwAtUTixlJwEgAAAbREw8=');
          1: SpotDTM := DTMFromString('mrAAAAHic42BgYNBmZGCwBGIrIDYAYhkgVgNifSDmB2JXoBorIHYAYl8g9gPiACC2BWI7IE4PMWZwM5dm8LSSZWjNcWYoS7RmKIqzYGgDshszHRl4gWrwYUYCGAYAo0ELyA==');
        End;
      End;
      3:
      Begin
        A:=Mainscreen.X1; B:=Mainscreen.Y1+30; C:=Mainscreen.X2; D:=292;
        Case I Of
          0: SpotDTM := DTMFromString('mwQAAAHic42RgYLjGyMBwCIgvA/EjIH4JxKJMDAyXgPRjIL4NxGFAddFA7A3EwUAcBcQhQBwHxKlA7A/ERbHWDNkR5gzVafYMLbkuDHWZTgyTK30YyhLtGGrSHRkqku0ZeIDqCGFGIjAcAABphRSg');
          1: SpotDTM := DTMFromString('mrAAAAHic42BgYPBiYWCwBGJPII4A4jYgTgHiMCCWAeLXDBB8H4ifAPELIP4JxH+B+BsQR7krMzRkODKUJ9ow1KbaMbTmODMUxlowVCbbMJQn2DDwANXgw4wEMAwAAC6VEwQ=');
        End;
      End;
    End;

    If FindDTM(SpotDTM,GoldX,GoldY,A,B,C,D) Then
    Begin
      SmartImage.DebugDTM(SpotDTM,IntToBox(A,B,C,D),Clred);
      Result:=True;
      If Debug Then
        Writeln('Found Gold spot DTM for I='+ToStr(I));
      FreeDTM(SpotDTM);
      If Debug Then
        Writeln ('DTM search completed in '+  IntToStr(T.GetTime) + ' msec');
      Exit;
    End;
    FreeDTM(SpotDTM);
  End;
  If Debug Then
    Writeln ('DTM search completed in '+  IntToStr(T.GetTime) + ' msec');
End;

Function FindGoldDTM: Boolean;
Begin
  Result:=False;
  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If TabBackpack.IsFull Then
    Exit(True);

  minimap.setAngle(MM_DIRECTION_NORTH);

  If Debug Then
    Writeln('Searching Spot: ' +tostr(Spot));

  If WaitFunc(@GoldDTMs,1,RandomRange(2500,3000)) Then
  Begin
    Mouse(Point(GoldX+GaussRangeInt(-5,5),GoldY+GaussRangeInt(-5,5)));
    If (IsMouseOverText(['posit','neral','depo'],RandomRange(1000,1200))) Then
    Begin
      If Debug Then
        Writeln('Found ore, clicking');
      FastClick(Mouse_Left);
      Wait(RandomRange(500,600));
      Result:=True;
    End Else
      If Debug Then
        takescreenshot('boom.bmp');
  End Else
    If Debug Then
      TakeScreenshot('Fail.bmp');
End;



Function Bank: Boolean;
Var
  H,I,CTS: Integer;
  X,Y: Integer;
  ChestBox: TBox;
  TPA,TPA2: TPointArray;
  ATPA: T2DPointArray;
  TBA: TBoxArray;
  MBP: TPoint;
Begin
  If Debug Then
    FunctionStop:= 'Bank: Entered';

  Result:=False;

  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If (Not FindDTM(GoldDTM, X, Y, TabBackpack.GetBounds)) And (Not FindDTM(BarDTM, X, Y, TabBackpack.GetBounds)) And (Not FindDTM(CoalDTM, X, Y, TabBackpack.GetBounds)) Then
    Exit;

  GetMousePos(X,Y);

  If PointInBox(Point(X,Y),Minimap.GetBounds) Then
    TabBackpack.MouseSlot(RandomRange(6,10),Mouse_Move);


  If FindDTM(GoldDTM, X, Y, TabBackpack.GetBounds) Then
  Begin
    If Debug Then
      Writeln('Found Gold in inventory, clicking');



    Mouse(Point(X+GaussRangeInt(-5,5),Y+GaussRangeInt(-5,5)),Mouse_Left);

    If (TabBackpack.CountDTM(GoldDTM) = 1) Then
    Begin
      OneOre:=1;
      If Debug Then
        Writeln('Only 1 gold ore found');
    End;
  End Else
  Begin
    If FindDTM(CoalDTM, X, Y, TabBackpack.GetBounds) Then
    Begin
      If Debug Then
        Writeln('Found coal in inventory, clicking');

      Mouse(Point(X+GaussRangeInt(-5,5),Y+GaussRangeInt(-5,5)),Mouse_Left);

      If (TabBackpack.CountDTM(CoalDTM) = 1) Then
      Begin
        OneOre:=1;
        If Debug Then
          Writeln('Only 1 coal ore found');
      End;
    End Else
    Begin
      If FindDTM(BarDTM, X, Y, TabBackpack.GetBounds) Then
      Begin
        If Debug Then
          Writeln('Found bar in inventory, clicking');

        Mouse(Point(X+GaussRangeInt(-5,5),Y+GaussRangeInt(-5,5)),Mouse_Left);

        If (TabBackpack.CountDTM(BarDTM) = 1) Then
        Begin
          OneOre:=1;
          If Debug Then
            Writeln('Only 1 gold bar found');
        End;
      End Else
        Exit;
    End;
  End;

  If (ChooseOption.OptionsExist(['Exam','mine','Examine','Canc','ncel','Cancel'],400)) Then
  Begin
    If Debug Then
      Writeln('Closing options menu');
    MouseBox(TabBackpack.GetBounds);
  End;

  findColorsTolerance(tpa, 6326431, MainScreen.GetBounds, 6,colorSetting(2,0.09,0.45));    //outercolor

  ATPA := TPA.Cluster(15,25);

  SetLength(TPA,0);

  atpa.filterBetween(0, 50);
  atpa.filterBetween(400, 100000);
  ATPA.sortFromFirstPoint(Point(330,200));

  If (Length(ATPA) = 0) Then
  Begin
    If Debug Then
      Writeln('No booth found.');
    Exit;
  End;

  If Debug Then
    Try
      debugATPA(ATPA);
    Except
      Writeln('Box out of bounds');
    End;

  H := High(ATPA);

  For I:= 0 To H Do
  Begin
    If Debug Then
      Writeln('Small Chest Length: '+ToStr(Length(atpa[i]))+' for I:= '+ToStr(I));

    ChestBox := GetTPABounds(ATPA[I]);
    ChestBox.Edit(-40,-5,+10,+20);
    ChestBox.SetLimit(Mainscreen.GetBounds);

    With ChestBox Do
    Begin
      If Not IsLoggedIn Then
        Exit;

      findColorsTolerance(tpa, 8950425, ChestBox, 18,colorSetting(2,0.11,0.20));    //innercolor

      If Debug Then
        Writeln('Silver Chest Length: '+ToStr(Length(TPA2))+' for I:= '+ToStr(I));

      If Length(TPA) > 5 Then
      Begin
        SetArrayLength(TBA, Length(TBA)+1);
        ChestBox.Edit(+30,0,0,-10);
        ChestBox.SetLimit(Mainscreen.GetBounds);
        TBA[High(TBA)] := ChestBox;
      End;

      SetLength(TPA,0);
    End;
  End;

  Try
    SmartImage.Clear;
    SmartImage.DrawBoxes(TBA, False, clRed);
  Except
    Writeln('Failed Drawing Boxes.');
  End;

  SetLength(ATPA,0);

  For H := 0 To High(TBA) Do
  Begin
    MBP := MiddleBox(TBA[H]);

    If (ChooseOption.OptionsExist(['Exam','mine','Examine','Canc','ncel','Cancel'],400)) Then
    Begin
      If Debug Then
        Writeln('Closing options menu');
      MouseBox(TabBackpack.GetBounds);
    End;

    MouseBox(TBA[H]);

    If (IsMouseOverText(['^ Pu','^ Pull','-^ Pu','-> Pu'],300)) Then
    Begin
      If Debug Then
        Writeln('Found chest, Clicking.');
      If Not SafeBank Then
      Begin
        If DidClick(True) Then
        Begin
          Result:=True;
          SetArrayLength(TBA,0);
          Exit;
        End Else
        Begin
          SetArrayLength(TBA,0);
          Exit;
        End;
      End Else
      Begin
        FastClick(Mouse_Right);

        If ChooseOption.Select(['Use','Gold','old', 'ore', 'bar'],RandomRange(400,500)) Then
        Begin
          If Debug Then
            Writeln('Found option to use box');
          Result := True;
          SetArrayLength(TBA,0);
          Exit;
        End Else
        Begin
          If Debug Then
            Writeln('DIDNT FIND OPTION TO DEPOSIT');
          MouseBox(TabBackpack.GetBounds,Mouse_Left);
          SetArrayLength(TBA,0);
          Exit;
        End;
      End;
    End;
  End;
  SetArrayLength(TBA,0);
  If Debug Then
    FunctionStop:= 'Bank: Finished';
End;


Function ToBank: Boolean;
Var
  X,Y: Integer;
  P: TPoint;
Begin
  If Debug Then
    FunctionStop:= 'ToBank: Entered';

  Result:=False;

  If AtBank Then
  Begin
    Result:=True;
    Exit;
  End;

  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If (Spot = 1) Or (Spot = 3) Then
  Begin
    If Debug Then
      Writeln('Walking to bank from lower spots');
    SPS.WalkPath(LRCPaths(1, True));
  End Else
  Begin
    If Debug Then
      Writeln('Walking to bank from higher spot');
    SPS.WalkPath(LRCPaths(2, True));
  End;

  CheckStuff;
  Moving;

  If Minimap.FindSymbol(P,MM_SYMBOL_BANK,Minimap.GetBounds) Then
  Begin
    Timeout.Reset;
    Timeout.Start;
    Timeout2.Reset;
    Timeout2.Start;
    Result := True;
    If Debug Then
      Writeln('Found bank symbol');
  End Else
    If Debug Then
      Writeln('No bank symbol found');

  If Debug Then
    FunctionStop:= 'ToBank: Finished';
End;

Procedure Banking;
Var
  I,X,Y: Integer;
  T: TTimeMarker;
  Coal: Boolean;
Begin
  If Debug Then
    FunctionStop:= 'Banking: Entered';

  SafeBank:=False;

  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  SmartImage.Clear;


  If Not ToBank Then
  Begin
    Writeln('Did not get to bank, logging in and out to reset map');
    Players[CurrentPlayer].ExitToLobby;
    Wait(RandomRange(2500,3500));

    If Debug Then
      Writeln('Loging back in');

    Players[CurrentPlayer].Login;
    Wait(RandomRange(2500,3500));
    CheckStuff;
    Minimap.ClickCompass;
    MainScreen.SetAngle(MS_ANGLE_HIGH);
    ToBank;
  End;

  For I:=0 to 2 Do
  Begin
    If Debug Then
      Writeln('Banking '+ToStr(I)+' times');

    If (Not FindDTM(GoldDTM, X, Y, TabBackpack.GetBounds)) And (Not FindDTM(BarDTM, X, Y, TabBackpack.GetBounds)) And (Not FindDTM(CoalDTM, X, Y, TabBackpack.GetBounds)) Then
      Exit;

    If TabBackpack.IsEmpty Then
      Exit;

    If WaitFunc(@Bank,100,4000) Then
    Begin
      If Debug Then
        Writeln('Clicking back success');

      SmartImage.Clear;

      T.Start;
      Repeat
        Wait(Random(100));
        If Not IsLoggedIn Then
          Exit;
        If T.GetTime > 5000 Then
        Begin
          If Debug Then
            Writeln('Chat text timeout, trying to bank again');
          SafeBank:=True;
          Bank;
          Wait(RandomRange(4000,6000));
        End;

        If OneOre=1 Then
        Begin
          If Debug Then
            Writeln('Only one ore skipping npc chat wait');
          Break;
        End;

        If T.GetTime > 15000 Then
        Begin
          If Debug Then
            Writeln('No chat in 15 seconds, giving up');
          Break;
        End;
      Until (ConversationBox.IsOpen);

      If Not (OneOre=1) Then
      Begin
        If Debug Then
          Writeln('Depositing '+ToStr(TabBackpack.CountDTM(GoldDTM))+' Gold');

        If (TabBackpack.CountDTM(GoldDTM) < 6) And (TabBackpack.CountDTM(GoldDTM) > 2) Then
          TypeSend('3',False) Else
        If (TabBackpack.CountDTM(GoldDTM) < 3) And (TabBackpack.CountDTM(GoldDTM) > 0) Then
          TypeSend('2',False) Else
        If TabBackpack.CountDTM(GoldDTM) > 5 Then
          TypeSend('4',False);

        If TabBackpack.CountDTM(GoldDTM) =0 Then
        Begin
          If Debug Then
            Writeln('No gold found, depositing '+ToStr(TabBackpack.CountDTM(CoalDTM))+' coal');

          If (TabBackpack.CountDTM(CoalDTM) > 0) Then
            Coal:=True;

          If (TabBackpack.CountDTM(CoalDTM) < 6) And (TabBackpack.CountDTM(CoalDTM) > 2) Then
            TypeSend('3',False) Else
          If (TabBackpack.CountDTM(CoalDTM) < 3) And (TabBackpack.CountDTM(CoalDTM) > 0) Then
            TypeSend('2',False) Else
          If TabBackpack.CountDTM(CoalDTM) > 5 Then
            TypeSend('4',False);
        End;

        If (Not FindDTM(GoldDTM, X, Y, TabBackpack.GetBounds)) And (Not FindDTM(CoalDTM, X, Y, TabBackpack.GetBounds)) Then
        Begin
          If Debug Then
            Writeln('Depositing '+ToStr(TabBackpack.CountDTM(BarDTM))+' Gold Bars');

          If (TabBackpack.CountDTM(BarDTM) < 6) And (TabBackpack.CountDTM(BarDTM) > 2) Then
            TypeSend('3',False) Else
          If (TabBackpack.CountDTM(BarDTM) < 3) And (TabBackpack.CountDTM(BarDTM) > 0) Then
            TypeSend('2',False) Else
          If TabBackpack.CountDTM(BarDTM) > 5 Then
            TypeSend('4',False);
        End;
      End;

      TabBackpack.WaitForShift(4000);

      Coal:=False;

      If Debug Then
        Writeln('Making sure gold dtm is set to gold ore');

      FreeDTM(GoldDTM);
      GoldDTM:= DTMFromString('mWAAAAHicY2FgYJjBxMDQB8SzgHgxEAcyMjAEAbEHEHsD8eZ+KYZEPzOGTb2SDJkh1gz8QD3ImBENgwAA4fkIew==');  //goldore
    End Else
      SafeBank:=True;

    If Debug Then
      Writeln('One ore variable back to 0');
    OneOre:=0;
  End;
  If Debug Then
    FunctionStop:= 'ToBank: Finished';
End;

Procedure RandomizePoints(TPA: TPointArray);
Var
  L,LL: Integer;
begin
  L:= High(TPA);
  LL:= L;
  While (L > 1) do
  begin
    TSwap(TPA[Random(LL)], TPA[Random(LL)]);
    Dec(L);
  end;
end;

Function GrabMaps: Boolean;
var
  Map: String;    //Map Locations
  Name: String;      //Map Names
  SPSFile: LongInt;
begin
  Name:= IncludePath + '0_0LRC';
  Map:= 'http://imageshack.com/a/img822/9172/t4yu.png';
  begin
    if (Not FileExists(Name)) then
    begin
      writeln('No file, downloading');
      SPSFile:=CreateFile(Name);
      CloseFile(SPSFile);
      SPSFile:= RewriteFile(Name, False);
      WriteFileString(SPSFile, GetPage(Map));
      CloseFile(SPSFile);
    end;
  end;
  Result:= (FileExists(IncludePath + 'SPS\img\runescape_surface\0_0SP.png'));
end;

Procedure RequirementsCheck;
begin
  If (Not GrabMaps) then
    RaiseException(erCustomError, 'SPS Maps Do Not Exist OR They Are Named Incorrectly!');
end;

Function FindDTMSlot(var X, Y: Integer; DTM, Slot: Integer): Boolean;
Var
  Bounds: TBox;
Begin
  Bounds:= TabBackpack.GetSlotBox(Slot);
  Result:= FindDTM(DTM, X, Y, Bounds);
End;

Procedure DropLRCBackup;
Var
  I, Bars, X, Y: Integer;
Begin
  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  TabBackpack.Open;
  TabBackpack.ClickDTM(GoldDTM,Mouse_Right,'rop');
  TabBackpack.ClickDTM(CoalDTM,Mouse_Right,'rop');
  TabBackpack.ClickDTM(Bars,Mouse_Right,'rop');
end;

Procedure DropLRC(GoldOres,GoldBars,CoalOres: Boolean);
Var
  X, Y,Invs: Integer;
  T,TT: TTimeMarker;
Begin
  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If Not ActionBars Then
  Begin
    DropLRCBackup;
    Exit;
  End;

  TabBackpack.Open;
  if (FindDTM(GoldDTM, X, Y, TabBackpack.GetBounds)) And (GoldOres) then
  begin
    If Debug Then
      Writeln('Found GoldDTM');
    OreCount := OreCount + TabBackpack.CountDTM(GoldDTM);
    T.Start;
    TT.Start;
    Invs:=TabBackpack.Count;
    Repeat
      If T.GetTime> 10000 Then
      Begin
        DropLRCBackup;
        Break;
      End;
      If TT.GetTime > 5000 Then
      Begin
        TypeByte(VK_ENTER);
        Wait(RandomRange(500,600));
        TypeByte(VK_ESCAPE);
        TypeByte(VK_ESCAPE);
        TT.Reset;
        TT.Start;
      End;
      If TabBackpack.Count<Invs Then
      Begin
        T.Reset;
        T.Start;
        Invs:=TabBackpack.Count;
        If Debug Then
          Writeln('Inv Decreased');
      End;
      Wait(Random(100));
      ConversationBox.Continue(True,True);
      TypeSend(GoldOre,False);
      Wait(RandomRange(0,100));
    Until Not (FindDTM(GoldDTM, X, Y, TabBackpack.GetBounds));
  end;
  if (FindDTM(BarDTM, X, Y, TabBackpack.GetBounds)) And (GoldBars) then
  begin
    If Debug Then
      Writeln('Found BarDTM');
    OreCount := OreCount + TabBackpack.CountDTM(BarDTM);
    T.Reset;
    T.Start;
    TT.Reset;
    TT.Start;
    Invs:=TabBackpack.Count;
    Repeat
      If T.GetTime> 10000 Then
      Begin
        DropLRCBackup;
        Break;
      End;
      If TT.GetTime > 5000 Then
      Begin
        TypeByte(VK_ENTER);
        Wait(RandomRange(500,600));
        TypeByte(VK_ESCAPE);
        TypeByte(VK_ESCAPE);
        TT.Reset;
        TT.Start;
      End;
      If TabBackpack.Count<Invs Then
      Begin
        T.Reset;
        T.Start;
        Invs:=TabBackpack.Count;
      End;
      Wait(Random(100));
      ConversationBox.Continue(True,True);
      TypeSend(GoldBar,False);
      Wait(RandomRange(0,100));
    Until Not (FindDTM(BarDTM, X, Y, TabBackpack.GetBounds));
  end;
  if (FindDTM(CoalDTM, X, Y, TabBackpack.GetBounds)) And (CoalOres) then
  begin
    If Debug Then
      Writeln('Found Coal to drop');
    OreCount := OreCount + TabBackpack.CountDTM(CoalDTM);
    T.Reset;
    T.Start;
    TT.Reset;
    TT.Start;
    Invs:=TabBackpack.Count;
    Repeat
      If T.GetTime> 10000 Then
      Begin
        DropLRCBackup;
        Break;
      End;
      If TT.GetTime > 5000 Then
      Begin
        TypeByte(VK_ENTER);
        Wait(RandomRange(500,600));
        TypeByte(VK_ESCAPE);
        TypeByte(VK_ESCAPE);
        TT.Reset;
        TT.Start;
      End;
      If TabBackpack.Count<Invs Then
      Begin
        T.Reset;
        T.Start;
        Invs:=TabBackpack.Count;
      End;
      Wait(Random(100));
      ConversationBox.Continue(True,True);
      TypeSend(CoalOre,False);
      Wait(RandomRange(0,100));
    Until Not (FindDTM(CoalDTM, X, Y, TabBackpack.GetBounds));
  end;
  ProgressReport;
end;

Function WaitFindDTM(DTM: Integer; Time: Integer = 500): Boolean;
Var
  T: TTimeMarker;
  X,Y: Integer;
Begin
  T.Start;
  Repeat
    Result:= FindDTM(DTM, X, Y, TabBackpack.GetBounds);
    Wait(100);
  Until (Result) Or (T.GetTime > Time);
End;

Procedure StaffRuneCheck;
Var
  FireRune, NatureRune, X, Y: Integer;
begin
  FireRune:= DTMFromString('mggAAAHicY2NgYPBiYmDwZ4LQIVAMYv8Dyv0HYiZGBgZWRgibA0jPlBeF487mZoZJPd0MQf7+DFxAeWyYEQeGAAC7yQvH');
  NatureRune:= DTMFromString('mggAAAHicY2NgYDjJxMBwFIjPAfFFID4LxMeBmJERKAnEP4DUPyBmZ4RgwToROG5vbGTISU9niI2MZOACqsGGGXFgCAAAbHcM2g==');
  TabBackpack.Open;

  If Not SFS Then
    HeatAlch:= ((WaitFindDTM(FireRune)) and WaitFindDTM(NatureRune)) Else     //returns true if it doesn't find either of these
    HeatAlch:= (WaitFindDTM(NatureRune));

  FreeDTM(FireRune);
  FreeDTM(NatureRune);
end;

{Procedure AlchOresBackup(BankBars: Boolean);
Var
  Spell,X,Y,Count: Integer;
begin
  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  StaffRuneCheck;

  If (Not HeatAlch) Then
  Begin
    BankBars:= JIC;
    If (BankBars) Then
    Begin
      Method:=0;
    End Else
      Method:=1;
    Exit;
  End;

  Spell := DTMFromString('mggAAAHicY2NgYHBmYmAwBWIzKPYDYn8g3sDIwLAYiFcB8WYoexsQK6YZMVxZY8OwZYI2w8np2gxOVgZgzA80CxtmxIEhAAAKJQzK');
  TabBackpack.Open;
  Count:= TabBackpack.CountDTM(GoldDTM);

  While (Count > 0) do
  begin
    If RunAways Then
      Break;

    if (Not Tab_Magic.Open) then
      Exit;

    If (Not FindDTM(Spell,X, Y, TabBackpack.GetBounds)) And (GetCurrentTab=Tab_Magic) Then
    Begin
      HumanMouseBox(702,302-50,721,322-50);
      FastClick(Mouse_Left);
    End;

    if (WaitFindDTM(Spell,4000)) then
    begin
      HumanMMouse(X, Y, 3, 3);
      if (WaitUptext('ast', 600)) then
        FastClick(Mouse_Left);

      If Not WaitFindDTMEx(GOLDDTM,X, Y, TabBackpack.GetBounds,200, 2000) Then
        WaitFindDTMEx(CoalDTM,X, Y, TabBackpack.GetBounds, MIY2,200, 2000);

      CheckStuff;

      Count:= TabBackpack.CountDTM(GoldDTM);
      HumanMMouse(X, Y, 3, 3);
      if (WaitUptext('ast', 600)) then
      begin
        FastClick(Mouse_Left);
        If Not TabBackpack.IsFull Then
          Wait(randomrange(1900,2200));
      end;
    end else
    begin
      if(IsUptext('umble')) then
        HumanMMouse(MICX, MICY, 0, 0);

      CheckStuff;
    end;
  end;
  TabBackpack.Open;
  FreeDTM(Spell);
end;   }

Function AlchOres(BankBars: Boolean): Boolean;
Var
  Spell,X,Y,Count: Integer;
  T: TTimeMarker;
begin
  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If Not ActionBars Then
  Begin
   // AlchOres(BankBars);
    Method:=0;
    Exit;
  End;

  StaffRuneCheck;

  If (Not HeatAlch) Then
  Begin
    BankBars:= JIC;
    If (BankBars) Then
    Begin
      Method:=0;
    End Else
      Method:=1;
    Exit;
  End;

  Spell := DTMFromString('mggAAAHicY2NgYHBmYmAwBWIzKPYDYn8g3sDIwLAYiFcB8WYoexsQK6YZMVxZY8OwZYI2w8np2gxOVgZgzA80CxtmxIEhAAAKJQzK');
  TabBackpack.Open;
  Count:= TabBackpack.CountDTM(GoldDTM)+TabBackpack.CountDTM(CoalDTM);

  T.Start;
  While (Count > 0) do
  begin
    If RunAways Then
      Break;

    ConversationBox.Continue(True,True);

    TypeSend(Alch,False);
    Wait(RandomRange(30,60));

    If Not FindDTM(GOLDDTM,X, Y, TabBackpack.GetBounds) Then
      If Not FindDTM(CoalDTM,X, Y, TabBackpack.GetBounds) Then
        Break;

    If CheckStuff Then
      Break;

    Count:= TabBackpack.CountDTM(GoldDTM)+TabBackpack.CountDTM(CoalDTM)-1;
    Mouse(X, Y, 3, 3);
    if (IsMouseOverText(['ast'], 600)) then
    begin
      If Debug Then
        Writeln('Found Spell uptext, clicking');
        FastClick(Mouse_Left);
        T.Reset;
        T.Start;
        If Not TabBackpack.IsFull Then
          Wait(randomrange(1900,2200)) Else
          Result:=True;
    end else
    Begin
      If Debug Then
        Writeln('No spell uptext found, hitting enter');
      TypeByte(VK_ENTER);
      Wait(RandomRange(500,600));
      TypeByte(VK_ESCAPE);
    End;
    If T.GetTime>10000 Then
    Begin
     // AlchOresBackup(False);
      Break;
    End;
  End;
  FreeDTM(Spell);
end;

{Procedure SuperHeatBackUp(BankBars: Boolean);
Var
  Spell, X, Y, Count: Integer;
begin
  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If Debug Then
      Writeln('Superheating');

  StaffRuneCheck;

  if (Not HeatAlch) then
  begin
    BankBars:= JIC;
    if (BankBars) then     //Swap the GoldDTM with BarsDTM.. Then Swap them Back..
    begin
      Method:=0;
    end else
      Method:=1;
    exit;
  end;

  Spell := DTMFromString('mWAAAAHicY2FgYJjBxMAwD4inAPF0IO5mZGDoB+IJQNwGxL+2uDP82ajC8OviOob3bU4M/EA9yJgRDYMAALa8DNg=');
  TabBackpack.Open;
  Count:= ItemAmount('inv', 'dtm', GoldDTM, []);

  If Debug Then
    Writeln('FOUND '+ ToStr(Count)+' GOLD ORES');

  While (Count > 0) do
  begin
    If Debug Then
      Writeln('FOUND GOLD ORE, STARTING TO HEAT');

    If RunAways Then
      Break;

    if (Not WaitGameTab(Tab_Magic, 3000)) then
      Gametab(Tab_Magic);

    If (Not FindDTM(Spell,X, Y, TabBackpack.GetBounds)) And (GetCurrentTab=Tab_Magic) Then
    Begin
      HumanMouseBox(702,302-50,721,322-50);
      FastClick(Mouse_Left);
    End;

    if (WaitFindDTMEx(Spell,X, Y, TabBackpack.GetBounds,200, 4000)) then
    begin
      If Debug Then
        Writeln('FOUND SPELL');

      HumanMMouse(X, Y, 3, 3);

      if (WaitUptext('ast', 600)) then
      Begin
        If Debug Then
          Writeln('CLICKING SPELL');
        FastClick(Mouse_Left);
      End;

      If WaitFindDTMEx(GOLDDTM,X, Y, TabBackpack.GetBounds,200, 2000) Then
      Begin
        If Debug Then
          Writeln('FOUND GOLD CLICKING');

        Count:= ItemAmount('inv', 'dtm', GoldDTM, [])-1;

        If Debug Then
          Writeln('FOUND '+ ToStr(Count)+' GOLD ORES');

        CheckStuff;

        HumanMMouse(X, Y, 4, 4);

        if (WaitUptext('ast', 600)) then
        Begin
          If Debug Then
            Writeln('CLICKED');

          FastClick(Mouse_Left);

          If Not TabBackpack.IsFull Then
            Wait(randomrange(1900,2500)) Else
            If (Count=0) And (Method=3) Then
              ToBank;

        End;
      End;
    end else
      CheckStuff;
  End;
  TabBackpack.Open;

  FreeDTM(Spell);

  If Debug Then
    Writeln('FINISHED HEATING');
End;      }

Function SuperHeat(BankBars: Boolean): Boolean;
Var
  Spell, X, Y, Count: Integer;
  T: TTimeMarker;
begin
  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If Not ActionBars Then
  Begin
    //SuperHeatBackup(BankBars);
    Method:=0;
    Exit;
  End;

  If Debug Then
      Writeln('Superheating');

  StaffRuneCheck;

  if (Not HeatAlch) then
  begin
    BankBars:= JIC;
    if (BankBars) then
    begin
      Method:=0;
    end else
      Method:=1;
    exit;
  end;

  Spell := DTMFromString('mWAAAAHicY2FgYJjBxMAwD4inAPF0IO5mZGDoB+IJQNwGxL+2uDP82ajC8OviOob3bU4M/EA9yJgRDYMAALa8DNg=');
  TabBackpack.Open;
  Count:= TabBackpack.CountDTM(GoldDTM);

  If Debug Then
    Writeln('FOUND '+ ToStr(Count)+' GOLD ORES');

  T.Start;
  While (Count > 0) do
  begin
    If Debug Then
      Writeln('FOUND GOLD ORE, STARTING TO HEAT');

    If RunAways Then
      Break;

    ConversationBox.Continue(True,True);

    TypeSend(SuperheatKey,False);
    Wait(RandomRange(30,60));

    If FindDTM(GOLDDTM,X, Y, TabBackpack.GetBounds) Then
    Begin
      If Debug Then
        Writeln('FOUND GOLD CLICKING');

      If Debug Then
        Writeln('FOUND '+ ToStr(Count)+' GOLD ORES');

      If CheckStuff Then
        Break;

      Mouse(X, Y, 4, 4);

      if (IsMouseOverText(['ast'], 600)) then
      Begin
        If Debug Then
          Writeln('Spell active clicking ore');

        Count:= TabBackpack.CountDTM(GoldDTM)-1;
        If Debug Then
          Writeln('Count : '+ToStr(Count));
        FastClick(Mouse_Left);

        T.Reset;
        T.Start;

        If Not TabBackpack.IsFull Then
        Begin
          If Debug Then
            Writeln('Inventory not full yet, going slow');
          Wait(randomrange(1900,2500))
        End Else
          If (Count=0) And (Method=3) Then
          Begin
            If Debug Then
              Writeln('Headed to bank b/c no more ores');
            ToBank;
            Break;
          End Else
            If (Method=4) Then
              Result:=True;
      End Else
      Begin
        If Debug Then
          Writeln('No Uptext found for superheat');
        TypeByte(VK_ENTER);
        Wait(RandomRange(500,600));
        TypeByte(VK_ESCAPE);
        TypeByte(VK_ESCAPE);
      End;
    End;
    If T.GetTime>10000 Then
    Begin
      If Debug Then
        Writeln('Been too long for superheating, trying backup');
    //  SuperHeatBackup(False);
      Break;
    End;
    Wait(Random(200));
  End;
  FreeDTM(Spell);

  If Debug Then
    Writeln('FINISHED HEATING');
End;

Procedure Mining;
Var
  X,Y,BegInv,BegXP,MaxCoal: Integer;
  AniTimer,XPInvTimer: TTimeMarker;
  L, I: Integer;
  P: TPoint;
  B: TBoxArray;
  BMP, BMP2,PixelShifts: TIntegerArray;
Begin
  If Debug Then
    FunctionStop:= 'Mining: Entered';

  If Debug Then
      Writeln('Mining afk');

  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  BegInv:=TabBackpack.Count;
 // BegXP:=GetXPBarTotal;
  AniTimer.Start;
  XPInvTimer.Start;




  MaxCoal:=RandomRange(60000,160000);

  Repeat

    SmartImage.Clear;
    If CheckStuff Then
    Begin
      Wait(RandomRange(5000,6000));
      FindGoldDTM;
      AniTimer.Reset;
      AniTimer.Start;
      XPInvTimer.Reset;
      XPInvTimer.Start;
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
    End;

    Wait(Random(100));

    If Not IsLoggedIn Then
      Break;

    If BegInv<TabBackpack.Count Then
    Begin
      AniTimer.Reset;
      AniTimer.Start;
      XPInvTimer.Reset;
      XPInvTimer.Start;
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
      BegInv:=TabBackpack.Count;
      If Debug Then
        Writeln('Inventory count increased');
    End;

   { If BegXP<GetXPBarTotal Then
    Begin
      MarkTime(XPInvTimer);
      MarkTime(AniTimer);
      BegXP:=GetXPBarTotal;
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
      If Debug Then
        Writeln('Xp increased');
    End;   }

    If Spot=3 Then
      If ((Method = 1) Or (Method = 4)) Then
        If CoalTimer.GetTime>MaxCoal Then
          Break;

    If WaitFunc(@GoldDTMs,1,RandomRange(2000,4000)) Then
    Begin
      AniTimer.Reset;
      AniTimer.Start;
      If Debug Then
        Writeln('Mining animation active');
    End Else
    Begin
      If TabBackpack.IsFull Then
        Break;
      GetMousePos(X,Y);
      If PointInBox(Point(X,Y),IntToBox(162,118,328,303)) Then
      Begin
        MouseOffClient(4);
        AniTimer.Reset;
        AniTimer.Start;
      End Else
        If Debug Then
          TakeScreenshot('Fail.bmp');
      If Not GoldDTMs Then
        Break Else
        Begin
          XPInvTimer.Reset;
          XPInvTimer.Start;
          AniTimer.Reset;
          AniTimer.Start;
        End;
    End;

    If Runaways Or Minimap.FindSymbol(P,MM_SYMBOL_BANK,IntToBox(661,83,705,126)) Then
    Begin
      If Debug Then
        Writeln('Found bank symbol');
      Exit;
    End;

    If XPInvTimer.GetTime>RandomRange(14000,15000) Then
    Begin
      If Debug Then
        Writeln('XP/Inv Timeout');
      If Not FindGoldDTM Then
        Break Else
        Begin
          XPInvTimer.Reset;
          XPInvTimer.Start;
        End;
    End;

    If AniTimer.GetTime>RandomRange(1500,2000) Then
    Begin
      If Debug Then
        Writeln('Animation Timeout');
      If Not FindGoldDTM Then
        Break Else
        Begin
          AniTimer.Reset;
          AniTimer.Start;
        End;
      XPInvTimer.Reset;
      XPInvTimer.Start;
    End;

    If (Method=1) And (ActionBars) Then
      If TabBackpack.Count>10 Then
      Begin
        DropLRC(True,True,True);
        BegInv:=TabBackpack.Count;
      End;

    If (Method = 2) then
    Begin
      If AlchOres(JIC) Then
        Break;
      BegInv:=TabBackpack.Count;
    End Else
      If (Method = 3) then
        SuperHeat(True) Else
        If (Method = 4) then
        Begin
          If SuperHeat(False) Then
            Break;
          If TabBackpack.IsFull Then
            Break;
          DropLRC(False,True,True);
          BegInv:=TabBackpack.Count;
        End;

    If (TabBackpack.Count<26) And ((HPPercent > (75))) And (Method<>2) And (Method<>3) And (Method<>4) Then
      AntiBan Else
      MouseOffClient(4);
  Until (TabBackpack.IsFull);

  If Debug Then
    Writeln('Inventory is full or spot is gone');

  If Debug Then
    FunctionStop:= 'Mining: Finished';
End;

Function FixPosition: Boolean;
Var
  HighBox: TBox;
Begin
  If Debug Then
    FunctionStop:= 'FixPosition: Entered';

  Result:=False;

  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If Spot=1 Then
  Begin
    Off := ToStr(SPS.GetPlayerPos);
    If (Not(Off = '(258,366)')) And (Not(Off = '(254,366)')) And (Not(Off = '(258,366)')) Then
    Begin
      If Debug Then
      Begin
        Writeln('Off of spot, correcting');
        Writeln('Off coordinates: '+Off);
      End;
      SPS.WalkToPos(Point(258,368));
      Result:=True;
    End;
  End Else
  Begin
    HighBox:=IntToBox(126,282,150,298);
    If Not PointInBox(SPS.GetPlayerPos,HighBox) Then
    Begin
      If Debug Then
      Begin
        Writeln('Off of spot, correcting');
        Writeln('Off coordinates: '+Off);
      End;
      SPS.WalkToPos(Point(142,294));
      Result:=True;
    End;
  End;

  If Debug Then
    FunctionStop:= 'FixPosition: Finished';
End;

Procedure Mainloop;
Var
  X,Y: Integer;
  P: TPoint;
Label
  Skip;
Label
  SkipUp;
Label
  SkipDown;
Begin
  If Debug Then
    FunctionStop:= 'MainLoop: Entered';

  CheckStuff;

  If (Not IsLoggedIn) Then
    Exit;

  If TabBackpack.IsFull Then
    If (Method=0) Or (Method=3) Then
      Banking;

  If Debug Then
      Writeln('Empty spot reset to 0');

  EmptySpot:=0;

  If (Spot=1) Or (Spot=3) Then
  Begin
    If Debug Then
      Writeln('Walking to low spot');

    If SPS.WalkPath(LRCPaths(1, False)) Then //bank to low
    Begin
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
      If Debug Then
        Writeln('Made it to low spot');
      Spot:=1;
    End Else
      SPS.BlindWalk(Point(325, 25));
  End Else
  Begin
    If Debug Then
      Writeln('Walking to high spot');

    If SPS.WalkPath(LRCPaths(2, False)) Then //bank to high spot
    Begin
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
      If Debug Then
        Writeln('Arrived at spot 2, high spot');
      Spot:=2;
    End Else
      SPS.BlindWalk(Point(198, -49));
  End;

  Moving;
  FixPosition;


  Repeat
    CheckStuff;
    If Not IsLoggedIn Then
      Exit;
    Wait(Random(100));

    SkipUp:
    If (Spot=1) Then
      If FindGoldDTM Then     //low or high spot
      Begin
        If Debug Then
          Writeln('Found Gold, EmptySpot back to 0');
        EmptySpot:=0;
        Mining;
        BreakHandler(BreakIn,BreakFor,Bir,Bfr);
        If (Not TabBackpack.IsFull) And (Spot=1) Then
          GoTo SkipDown;
      End Else
      Begin
        BreakHandler(BreakIn,BreakFor,Bir,Bfr);
        EmptySpot := EmptySpot + 1;
        If Debug Then
          Writeln('Did not find gold, emptyspot is: '+ToStr(EmptySpot));

        SkipDown:
        If RunPercent < 50 Then
        Begin
          If Debug Then
            Writeln('Run energy low, resting');
          Setrest;
          Repeat
            Timeout.Reset;
            Timeout.Start;
            Timeout2.Reset;
            Timeout2.Start;
            If Runaways Then
              Exit;
            CheckStuff;
            If Not IsLoggedIn Then
              Exit;
            setrest;
            wait(100);
          Until RunPercent > 90;
          Minimap.ToggleRun(True);

          If Debug Then
            Writeln('Run energy restored');

          GoTo SkipUp;
        End;
        CheckStuff;

        If EmptySpot >= 2 Then
        Begin
          If Debug Then
            Writeln('EmptySpot too high, going to look for coal');

          If SPS.WalkPath(LRCPaths(4, False)) Then
            Spot:=3 Else
            SPS.BlindWalk(Point(309, -38));

          Moving;

          If FindGoldDTM Then
          Begin
            If Debug Then
              Writeln('Found coal');
            CoalTimer.Reset;
            CoalTimer.Start;
            Mining;
          End;

          If TabBackpack.IsFull Then
            Break;

          EmptySpot:=0;
        End;

        If Debug Then
            Writeln('Walking to high spot');

        If SPS.WalkPath(LRCPaths(3, False)) Then //low to high spot
        Begin
          Spot:=2;
          If Debug Then
            Writeln('Arrived at spot 2, high spot');
        End Else
          Exit;

        Moving;
        FixPosition;
      End;

      If Spot=2 Then
        If FindGoldDTM Then  //high spot
        Begin
          If Debug Then
            Writeln('Found gold, emptyspot back to 0');
          EmptySpot:= 0;
          Mining;
          If Not TabBackpack.IsFull Then
            GoTo Skip;
        End Else
        Begin
          Skip:
            EmptySpot:= EmptySpot + 1;
            If Debug Then
              Writeln('Did not find gold, emptyspot is '+ToStr(EmptySpot));
            CheckStuff;

            If Debug Then
                Writeln('Walking from high to low spot');

            If SPS.WalkPath(LRCPaths(3, True)) Then  //high to low spot
            Begin
              Timeout.Reset;
              Timeout.Start;
              Timeout2.Reset;
              Timeout2.Start;
              If Debug Then
                Writeln('Arrived at spot 1, low spot');
              Spot := 1;
            End Else
              Exit;
          Moving;
          FixPosition;
        End;
  Until ((TabBackpack.IsFull) Or (Minimap.FindSymbol(P,MM_SYMBOL_BANK,Minimap.GetBounds)));

  If (Method = 3) Then
  Begin
    SuperHeat(True);
  End;

  ProgressReport;
  If ((Method = 0) Or (Method = 3)) Then
  Begin
    If Debug Then
      Writeln('Banking for method '+ToStr(Method));
    Banking;
  End Else
    If ((Method = 1) Or (Method = 4)) Then
    Begin
      If Debug Then
        Writeln('Dropping for method '+ToStr(Method));
      If (Method = 4) Then
        SuperHeat(False);
      DropLRC(True,True,True);
      FindGoldDTM;
    End Else
      If (Method = 2) Then
        AlchOres(JIC);

  If RunPercent < 50 Then
  Begin
    If Debug Then
      Writeln('Low energy resting');
    Setrest;
    Repeat
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
      Wait(100);
      If Runaways Then
        Exit;
      CheckStuff;
      If Not IsLoggedIn Then
        Exit;
      setrest;
    Until RunPercent > 90;
    Minimap.ToggleRun(True);
  End;
  If Debug Then
    FunctionStop:= 'MainLoop: Finished';
End;

Procedure LastRun;
Begin
  Writeln(FunctionStop);
End;

Procedure Setup;
Var
X,Y: Integer;
Begin
  If Debug Then
    FunctionStop:= 'Setup: Entered';

  ClearDebug;
  RequirementsCheck;
  AutoUpdateMe;
  SmartEnableDrawing := True;

  initPlayerForm(); // initiate your settings
  runPlayerForm();  // run the form

  // use this so the script doesn't continue if the user exits out of the form
  if (not playerForm.isScriptReady) then
    terminatescript;

  declarePlayers();

  If Players[CurrentPlayer].strings[0] = 'DirectX' Then
    smartPlugins := ['OpenGL32.dll','d3d9.dll'];

  SetupSRL;


  If Not IsLoggedIn Then
  Begin
    If Not Players[CurrentPlayer].Login Then
      TerminateScript;

    Writeln('Just loggedin, waiting a bit');
    Wait(RandomRange(6000,10000));
  End;


  If Not Debug Then
    DisableSRLDebug:=True;

  spsAnyAngle:=True;
  SPS.Setup('0_0LRC', 'Runescape_Surface\');
  Minimap.ClickCompass;
  MainScreen.SetAngle(MS_ANGLE_HIGH);
  Players[CurrentPlayer].FindMod := False;

  StartingExperience:=ChatBox.GetXP;
  If FindNormalRandoms Then
    Wait(RandomRange(2000,3000));

  Case PTS Of
    1: NewPouch:=61;  //titan
    2: NewPouch:=55;  //golem
  End;

  {If UsingFamiliar Then
    SummoningTimer:=(GetSystemTime-((NewPouch-GetNPCTimer)*60*1000)) Else
    NoFamiliar:=True; }

  OldHP:=HPPercent;
  Spot:=1;
  Timeout.Reset;
  Timeout.Start;
  Timeout2.Reset;
  Timeout2.Start;

  AddOnTerminate('F33DTM');
  If Debug Then
    AddOnTerminate('LastRun');
  SetDTM;

 { If ((Method = 2) Or (Method = 3) Or (Method = 4)) Then
  Begin
    TabBackpack.Open;

    If SFS Then
    Begin
      If FindDTM(Staff, X, Y, TabBackpack.GetBounds) Then
      Begin
        Mouse(X,Y,0,0);
        FastClick(Mouse_Left);
        Wait(600);
      End
      Else
      Begin
         // Gametab(Tab_Equip);
          Wait(300);

        If FindDTM(Staff, X, Y, TabBackpack.GetBounds) Then
          Writeln('Staff is equipped') Else
          Begin
            Writeln('Couldnt find staff, cant use this option');
            F33DTM;
            Players[CurrentPlayer].Logout;
            TerminateScript;
          End;
      End;
    End;
  End;      }

  Case Method Of
    0: Begin Writeln('I see you are banking your junk, good luck!'); End;
    1: Begin  Writeln('You are using the drop only method...get that xp!'); End;
    2: Begin Writeln('You are using the alching method...goodbye gold'); End;
    3: Begin Writeln('You are using the superheating and banking method..You are a boss'); End;
    4: Begin Writeln('You are using the superheating and dropping method...What a waste!'); End;
  End;

 // SummoningRenew(PTS,True);

  If Debug Then
    FunctionStop:= 'Setup: Finished';
End;

Begin
  Setup;
  Repeat
    Wait(Random(100));
    If Not POSDebug Then
    Begin
      Mainloop;
    End Else
      Begin
        SPS.DebugPlayerPos;
      End;
    If Not IsLoggedIn Then
    Begin
      If Not IsLoggedIn Then
      Begin
        Players[CurrentPlayer].Login;
        Wait(RandomRange(4000,5000));
        Minimap.ClickCompass;
        MainScreen.SetAngle(MS_ANGLE_HIGH);
       { If UsingFamiliar Then
          SummoningTimer:=(GetSystemTime-((NewPouch-GetNPCTimer)*60*1000)) Else
          NoFamiliar:=True; }
      End;
    End;
  Until Players.GetActive()=0;
End.
