Program AshamanggzzLRC;
  {$IFDEF RAYMONDPOWNS}{wrappers} function FloodFillTPAWrap(const TPA: TPointArray): T2DPointArray; var tempATPA: T2DPointArray; begin tempATPA:= FloodFillTPA(TPA); Result:= tempATPA; SetLength(tempATPA, 0); end; function FindTPAEdges(const p: TPointArray): TPointArray; begin FindTPAEdgesWrap(p, result); end; Function RotatePoints(Const P: TPointArray; A, cx, cy: Extended): TPointArray; begin RotatePointsWrap(P, A, cx, cy, result); end; function TPAFromCircle(const CX, CY, Radius: Integer): TPointArray; begin TPAFromCircleWrap(CX, CY, Radius, result); end; function TPAFromEllipse(const CX, CY, XRadius, YRadius : Integer): TPointArray; begin TPAFromEllipseWrap(CX, CY, XRadius, YRadius, result); end; function TPAFromBox(const Box : TBox) : TPointArray; begin TPAFromBoxWrap(Box, result); end; Function ReturnPointsNotInTPA(Const TotalTPA: TPointArray; const Box: TBox): TPointArray; begin ReturnPointsNotInTPAWrap(TotalTPA, Box, result); end; function CombineIntArray(const Ar1, Ar2: TIntegerArray): TIntegerArray; begin CombineIntArrayWrap(Ar1, Ar2, result); end; function ReArrangeandShortenArray(const a: TPointArray; Dist: Integer): TPointArray; begin ReArrangeandShortenArrayWrap(a, Dist, result); end; function ReArrangeandShortenArrayEx(const a: TPointArray; w, h: Integer): TPointArray; begin ReArrangeandShortenArrayExWrap(a, w, h, result); end; function CombineTPA(const Ar1, Ar2: TPointArray): TPointArray; begin CombineTPAWrap(Ar1, Ar2, Result); end; function RemoveDistTPointArray(x, y, dist: Integer;const ThePoints: TPointArray; RemoveHigher: Boolean): TPointArray; begin RemoveDistTPointArrayWrap(x, y, dist, ThePoints, RemoveHigher, Result); end; function TPAFromText(const text, font: String; var w,h: Integer): TPointArray; begin TPAFromTextWrap(text, font, w, h, result); end; function GetColors(const Coords: TPointArray): TIntegerArray; begin GetColorsWrap(Coords, Result); end; function Explode(del, str: string): TStringArray; begin ExplodeWrap(del, str, Result); end; function MergeATPA(const ATPA : T2DPointArray): TPointArray; begin MergeATPAWrap(ATPA, Result); end; function SplitTPA(arr : TPointArray; dist : Integer) : T2DPointArray; begin SplitTPAWrap(arr, dist, result); end; function SplitTPAEx(arr : TPointArray; w, h : integer) : T2DPointArray; begin SplitTPAExWrap(Arr, w, h, result); end; function ClearTPAFromTPA(arP, ClearPoints : TPointArray) : TPointArray; begin ClearTPAFromTPAWrap(arP, ClearPoints, result); end; function TPAToATPAEx(arP : TPointArray; w, h : integer) : T2DPointArray; begin TPAtoATPAExWrap(arP, w, h, result); end; function TPAToATPA(arP : TPointArray; dist : Integer) : T2DPointArray; begin TPAtoATPAWrap(arP, dist, result); end; function FindGapsTPA(TPA : TPointArray; MinPixels : integer) : T2DPointArray; begin FindGapsTPAWrap(tpa, MinPixels, result); end; {$ENDIF}
  {$Define SMART}
  {$I SRL-6/SRL.Simba}
  {$I SPS/lib/SPS-RS3.Simba}

Var
  PTS: Integer;
  Method: Integer;
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                  Begin of user setup                              //
//                Fill in the fields below                           //
//                                                                   //
///////////////////////////////////////////////////////////////////////

Const

  SRLStats_Username = '';         // ***Leave blank if you don't have a stats account***
  SRLStats_Password = '';

  {For Alch or Superheat Methods}
  SFS = True;                     // ***Set To True If SuperHeating Or Alching And Using FireStaff (Any fire rune substitute staff will work)***
  JIC = True;                     // ***If True, when superheating or alching, if out of runes, it will bank ores/bars.. else drop them if false***
  Superheats = '4';               // ***Which key do you have the superheat spell bound to?***
  Alch = '5';                     // ***Which key do you have the low alch spell bound to?***

  {Drop Settings}
  GoldOre = '1';                  // ***Which key do you have gold ores bound to?***
  GoldBar = '2';                  // ***Which key do you have gold bars bound to?***
  CoalOre = '3';                  // ***Which key do you have coal ore bound to?***

  {Overall Methods}
  ActionBars = True;               // ***Do you want to use the action bar to drop?***
  DMP = True;                     // ***If the SPS Maps aren't found, Download them and save them automatically, you should leave this as true***
  Timeouts = True;                // ***Do you want script to shutdown if nothing has happened for several minutes?***

  {Break Settings}
  TakeBreaks   = False;            // ***Do you want to take breaks?***
  BreakIn      = 600;             // ***How long before we take a break? (minutes)***
  BreakFor     = 15;              // ***How long will we break for? (minutes)***
  Bir          = 13;              // ***Random minutes to add/subtract from how long until we break***
  Bfr          = 7;               // ***Random minutes to add/subjtract from break duraction***

Procedure DeclarePlayers;
Begin
  Players.Setup(['Player1'], 'PlayerList'); //***Fill this out, Player1 = Name of the account in player manager, PlayerList = name of the player file***
  SetLength(Players,1);

  //***If NOT using the player manager, fill out the loginname and password below, otherwise ignore those two***
  With players[0] Do
  Begin
  // loginName := '';      {Remove the "//" from this line if you arent using player manager}
  // password := '';       {Remove the "//" from this line if you arent using player manager}
    IsActive := True;
    World := 84;
    Method:= 0;           //0 for banking, 1 for dropping, 2 for alching, 3 for superheat and bank, 4 for superheat and drop
  End;
  CurrentPlayer := 0;
End;


///////////////////////////////////////////////////////////////////////////////////////////
//                                                                                       //
//                            End of user setup                                          //
//           Don't touch below this line unless you know what you're doing!!             //
//                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////


Const
  ScriptVersion = '8.04';
  E = 200;
  F = 462;
  Debug = False;
  POSDebug = False;
  AnimationDebug = False;

Var
 Spot,SpotDTM,A,B,C,D,GoldX,GoldY,SummoningTimer,M,NewPouch: Integer;
 StartTime,CurrentTime: Int64;
 W,X,Y,Z,RealBTime,BreakRounds,TotalBreaks: Integer;
 OreCount,XP,OneOre,BarDTM,Staff,EmptySpot,StartingExperience,GoldDTM,CoalDTM: Integer;
 CurrentBTime,Timeout,Timeout2,CoalTimer: TTimeMarker;
 XPH,OresPH,HP,OldHP: Extended;
 HeatAlch,SafeBank,NoFamiliar: Boolean;
 Off,FunctionStop: String;

 {*******************************************************************************
Function AutoupdateMe;
By: Shuttleu
Edited By: Ashaman88
Description: Autoupdates Script.
*******************************************************************************}
Procedure AutoUpdateMe;
Var
  Neifile: Integer;
  OnlineVersion, NewScript, NeiFeilNennen: String;
Begin
  Writeln('Checking for script updates...');
  OnlineVersion := GetPage('http://ashamanggzzlrcminer.googlecode.com/git/Version.txt');
  Writeln('Online Version: '+ToStr(OnlineVersion));
  Writeln('Local Version: '+ToStr(ScriptVersion));
  If (trim(OnlineVersion) > ScriptVersion) Then
  Begin
    WriteLn('Newer script version online!');
    WriteLn('Autoupdating to newer version.');
    NewScript := GetPage('http://ashamanggzzlrcminer.googlecode.com/git/AshamanggzzLRC.simba');
    NeiFeilNennen := ScriptPath+ 'LRC Miner V'+OnlineVersion+' by A&B.simba';
    Neifile := Rewritefile(NeiFeilNennen, true);
    Try
      WriteFileString(Neifile, NewScript);
    Except
      Begin
        WriteLn('Fatal error writing to '+NeiFeilNennen+'!!');
        Terminatescript;
      End;
    End;
    CloseFile(Neifile);
    WriteLn('New script downloaded to '+NeiFeilNennen+'!! Please use this one!!');
    TerminateScript;
  End Else
    WriteLn('You have the latest version of the script!');
End;

Function FindNormalRandoms: Boolean;
Begin
  Result:= ExitSquealOfFortune Or ClaimSpinTicket;
End;

procedure mouseOffClient(Direction: Integer; Stay: Boolean);  overload;
var
  B: TBoxArray;
  P: TPoint;
  i, W, H,X,Y: Integer;
begin
  GetClientDimensions(W, H);
  GetMousePos(X,Y);
  if (X < 0) or (X > W) or (Y < 0) or (Y > H) then
     exit;

  SetLength(B, 4);

  B[OFF_CLIENT_TOP] := [-300, -300, W, 0]; // top
  B[OFF_CLIENT_BOTTOM] := [0, H, W, H +300];  // bottom
  B[OFF_CLIENT_LEFT] := [0-300, 0, 0, H];   // left
  B[OFF_CLIENT_RIGHT] := [W, 0, W +300, H];  // right

  if (Direction = OFF_CLIENT_RANDOM) then
    i := Random(4)
  else
    i := Direction;

  P := Point(RandomRange(B[i].X1, B[i].X2), RandomRange(B[i].Y1, B[i].Y2));
  Mouse(Point(P.X, P.Y), MOUSE_MOVE);
end;

Procedure SetDTM;
Begin
  Writeln('Loading viruses...I mean DTMs');

  W := (BreakIn * 60000);
  X := (BreakFor * 60000);
  Y := RandomRange(-BIR * 60000, BIR * 60000);
  Z := RandomRange(-BFR * 60000, BFR * 60000);

  GoldDTM := DTMFromString('mWAAAAHicY2FgYJjBxMDQB8SzgHgxEAcyMjAEAbEHEHsD8eZ+KYZEPzOGTb2SDJkh1gz8QD3ImBENgwAA4fkIew==');
  BarDTM:= DTMFromString('mbQAAAHicY2VgYJjPxMCwBIgXA/FsIF4FxAqMDAzyQKwCxKpArAjEC+rFGC4tlwXjSHcehhur5Rj4gfrRMSMWDAYA8jMK5w==');
  CoalDTM := DTMFromString('mggAAAHicY2NgYMhjYmAoAuIkIM4C4gogLgHiJ0C52wwQ+g0QPwTiF0Csri4HxuGuBgzRnsYMWSHWDJKSwgz8QDlsmBEHhgAAKPUMHA==');
  Staff := DTMFromString('mWAAAAHicY2FgYJjKxMDQBcQzgXgBELcyMjBMBOIGIK4AYmVpaQYTZWUGSWFhhk8zeRjkgHqQMRMaBgEAu6MHoA==');
End;

Procedure F33DTM;
Begin
  FreeDTM(GoldDTM);
  FreeDTM(BarDTM);
  FreeDTM(CoalDTM);
  FreeDTM(Staff);
  If DTMExists(SpotDTM) Then
    FreeDTM(SpotDTM);
End;

Function BreakHandler(BreakIn, BreakFor, randBreakIn, randBreakFor: Integer): Boolean;
Var
  H,M,S: Integer;
Begin
  FUNCTIONSTOP:='BREAK ENTERED';

  If Not IsLoggedIn Then
    Exit;

  If (GetTimeRunning < ((W) + (Y) + BreakRounds)) Then
    Exit Else
    If (GetTimeRunning > ((W) + (Y) + BreakRounds)) Then
    Begin
      RealBTime := Round((X+Z)/60000);
      Writeln('Taking a break for about ' + IntToStr(RealBTime) + ' minutes.');
      Players[CurrentPlayer].Logout;
      CurrentBTime.Reset;
      CurrentBTime.Start;
      Repeat
        Wait(21000);
        ConvertTime((X+Z)-CurrentBTime.GetTime,H,M,S);
        Writeln('Breaktime left: '+IntToStr(H)+':'+IntToStr(M)+':'+IntToStr(S));
      Until(CurrentBTime.GetTime>(X+Z));
      Writeln('Logging in.');
      Players[CurrentPlayer].Login;
      Wait(4000);
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
      Result := IsLoggedIn;
      Minimap.ClickCompass;
      MainScreen.SetAngle(MS_ANGLE_HIGH);
      IncEx(BreakRounds, (W) + (X));
      Inc(TotalBreaks);
      Writeln('The next break will occur in about ' + IntToStr(BreakIn) + ' minutes.');
      W := (BreakIn * 60000);
      X := (BreakFor * 60000);
      Y := RandomRange(-BIR * 60000, BIR * 60000);
      Z := RandomRange(-BFR * 60000, BFR * 60000);
    End;
  FUNCTIONSTOP:='BREAK EXIT';
End;

Function HPPercent: Integer;                                        //Method
Var
  CTS: Integer;
Begin
  If Not IsLoggedIn Then
    Exit;

  CTS := GetToleranceSpeed;
  SetColorToleranceSpeed(2);

  SetToleranceSpeed2Modifiers(3.82,0.80);                                //Method
  Result:= Round(CountColorTolerance(15724370,IntToBox(48,410,151,417),13)/314 * 100);
  SetColorToleranceSpeed(CTS);
  SetToleranceSpeed2Modifiers(0.2,0.2);
End;

Function SetRest: Boolean;
Var
  T: TTimeMarker;
Begin
  Result:=Minimap.IsResting;
  If Result Then
    Exit;

  MouseBox(IntToBox(768,29,786,46),Mouse_Right,Mouse_Human);
  ChooseOption.Select(['Rest','est'],RandomRange(700,900));

  T.Start;
  While Not Result Do
  Begin
    Result:=Minimap.IsResting;
    If T.GetTime > 5000 Then
      Break;
  End;
End;

Function RunPercent: Integer;
Var
  CTS,Count: Integer;
Begin
  If Not IsLoggedIn Then
    Exit;

  CTS := GetToleranceSpeed;
  SetColorToleranceSpeed(2);                      //100      75       50        25         0
                                                  //429     383      302       263       149
  SetToleranceSpeed2Modifiers(0.25,1.76);
  Count:= CountColorTolerance(3504305,IntToBox(766,24,786,48),25);
  SetColorToleranceSpeed(CTS);
  SetToleranceSpeed2Modifiers(0.2,0.2);

  If Count >= 428 Then
  Begin
    Result:= 100;
    Exit;
  End;

  If Count <= 150 Then
  Begin
    Result:= 0;
    Exit;
  End;

  Result:=Round((0.0005 * (count * count)) + (0.0549 * count) - 17.599);
End;

//by Home       //tbox.split(w, h)
function AreaToBoxArray(const AreaX1, AreaY1, AreaX2, AreaY2, Width, Height: Integer): TBoxArray;
var
  AreaW, AreaH: Integer;
  BoxX, BoxY: Integer;
  x, y, i: Integer;
begin
  FUNCTIONSTOP:='AREATTOBOX ENTERED';

  // Calculate the area dimensions
  AreaW := AreaX2 - AreaX1 + 1;
  AreaH := AreaY2 - AreaY1 + 1;

  // Calculate the number of boxes in each dimension
  BoxX := AreaW div Width;
  if AreaW mod Width <> 0 then Inc(BoxX);
  BoxY := AreaH div Height;
  if AreaH mod Height <> 0 then Inc(BoxY);

  // Set the number of boxes
  SetLength(Result, BoxX * BoxY);

  // Calculate the boxes
  i := 0;
  for y := 0 to BoxY - 1 do
    for x := 0 to BoxX - 1 do
    begin
      Result[i] := IntToBox(AreaX1 + x * Width,
        AreaY1 + y * Height,
        Min(AreaX2, AreaX1 + (x + 1) * Width - 1),
        Min(AreaY2, AreaY1 + (y + 1) * Height - 1));
      Inc(i);
    end;
  FUNCTIONSTOP:='AREABOX EXIT';
end;

Procedure CheckMovingObjs(RClick: Boolean);
var
  TBA: TBoxArray;
  MidBox: TPoint;
  TIA: TIntegerArray;
  H,I,J,X,Y,T: Integer;
  TPA,PBox: TPointArray;
begin
  FUNCTIONSTOP:='CHECKMOVINGOBJS ENTERED';

  if not IsLoggedIn then Exit;

  SetColorToleranceSpeed(1);
  SetToleranceSpeed2Modifiers(0.2, 0.2);

  PBox := TPAFromBox(MainScreen.PlayerBox);
  TBA := AreaToBoxArray(Mainscreen.X1, Mainscreen.Y1, Mainscreen.X2, Mainscreen.Y2, 35, 35);
  TIA := GetPixelShift(TBA, 300);

  for H := 0 to High(TBA) do
  begin
    if (TIA[H] > 100) then
    begin
      MidBox := MiddleBox(TBA[H]);
      SetArrayLength(TPA, Length(TPA)+1);
      TPA[High(TPA)] := MidBox;
    end;
  end;

  ClearTPAFromTPAWrap(TPA, PBox, TPA);
  if (Length(TPA) < 1) then Exit;

  I := Random(Length(TPA));
  Mouse(Point(TPA[I].X+GaussRangeInt(-10,10), TPA[I].Y+GaussRangeInt(-10,10)),Mouse_Move,Mouse_Human);

  if RClick then
  begin
    FastClick(Mouse_Right);
    if (chooseOption.isOpen(500)) then
      J := Length(ChooseOption.__getOptions());
    Wait(GaussRangeInt(J*75, J*120));

    ChooseOption.Close
  end;
  SetArrayLength(TPA,0);

  FUNCTIONSTOP:='CHECKMOVEOBJ EXIT';
end;

Function Antiban: Boolean;
Var
  I: Integer;
Begin
  I := Random(600);
  Case I Of
    1..3:
      Begin
        Wait(GaussRangeInt(0, 5000));
      End;
    4..25:
      Begin
        TabStats.GetSkillLevel(Skill_Herblore,SKILL_DYNAMIC);
        Wait(GaussRangeInt(1000,2000));
        TabBackpack.Open;
      End;
    80..150:
      Begin
        CheckMovingObjs(False);
      End;
    151..180:
      Begin
        CheckMovingObjs(True);
      End;
    181..200:
      Begin
        SleepAndMoveMouse(GaussRangeInt(400,500));
        Result:=True;
      End;
    201..600:
      Begin
        MouseOffClient(4,True);
        Wait(RandomRange(3000, 15000));
        Result:=True;
      End;
  End;
  If (TabBackpack.Count<25) And ((HPPercent > (75))) Then
    Wait(GaussRangeInt(3000,4000));
End;

Procedure ProgressReport;
Var
  TTB: Integer;
Begin
  If (Not Debug) And (Not AnimationDebug) And (Not POSDebug) Then
    ClearDebug;

  TTB := (((W) + (Y) + BreakRounds)-GetTimeRunning);

  OreCount := OreCount + TabBackpack.CountDTM(GoldDTM)+TabBackpack.CountDTM(CoalDTM);
  XP := (OreCount * 65);
  XPH := Round(XP * (3600.0 / (GetTimeRunning / 1000.0)));
  OresPH := Round((OreCount * (3600.0 / (GetTimeRunning / 1000.0))));

  Writeln('========Ashaman&ggzzLRC=========');
  Writeln('==========Version: '+ScriptVersion+'==========');
  Writeln('Time Running: ' + ToStr(TimeRunning));
  Writeln('Ores Mined: ' + IntToStr(OreCount));                       //Method
  Writeln('Experience Earned: ' + IntToStr(XP));
  Writeln('Experience/Hour: ' + ToStr(XPH));
  Writeln('Ores/H: ' + ToStr(OresPH));
  Writeln('================================');
  If TakeBreaks Then
    Writeln('Time until break: '+MsToTime(TTB, Time_Bare));

  StatsIncVariable('Gold Ore (Mined)', TabBackpack.CountDTM(GoldDTM));
  StatsCommit;
End;

Function ToBank: Boolean; Forward;

Function CheckStuff: Boolean;
Begin
  Result:=False;

  If Not IsLoggedIn Then
  Begin                                                 //Method
    If Not Players[CurrentPlayer].Login Then
      TerminateScript;
    Wait(RandomRange(4000,6000));
    Minimap.ClickCompass;
    MainScreen.SetAngle(MS_ANGLE_HIGH);
    FindNormalRandoms;
    Timeout.Reset;
    Timeout.Start;
    Timeout2.Reset;
    Timeout2.Start;
    Result:=True;
  End;

  If Timeout.GetTime>120000 Then
  Begin
    Writeln('Nothing has happened for too long, resetting focus.');
    Timeout.Reset;
    Timeout.Start;
    Minimap.ClickCompass;
    MainScreen.SetAngle(MS_ANGLE_HIGH);
    FindNormalRandoms;
    If Not ToBank Then
    Begin
      Writeln('Did not get to bank, logging in and out to reset map');
      Players[CurrentPlayer].ExitToLobby;
      Wait(RandomRange(2500,3500));

      If Debug Then
        Writeln('Loging back in');

      Players[CurrentPlayer].Login;
      Wait(RandomRange(2000,3000));                                                                    //Method
      Minimap.ClickCompass;
      MainScreen.SetAngle(MS_ANGLE_HIGH);
      FindNormalRandoms;
      ToBank;
    End;
  End;

  If Timeouts Then
    If Timeout2.GetTime>300000 Then
    Begin
      Writeln('Nothing has happened for too long, shutting down.');
      Players[CurrentPlayer].Logout;
      TerminateScript;
    End;

  If FindNormalRandoms Then
    If Not IsLoggedIn Then
      TerminateScript Else                                         //Method
      Begin
        Minimap.ClickCompass;
        MainScreen.SetAngle(MS_ANGLE_HIGH);
        If Debug Then
          Writeln('Found squeal stuff');
        Result:=True;
      End;
End;

Function AtBank: Boolean;
Var
  BankBox: TBox;
Begin
  BankBox:=IntToBox(100,65,125,80);
  If Not PointInBox(SPS.GetPlayerPos,BankBox) Then
  Begin
    If Debug Then
    Begin
      Writeln('Not at bank');
      Writeln('bank coordinates: '+Off);
    End;
  End Else
    Result:=True;
End;

Function LRCPaths(Which: Integer; Invert: Boolean): TPointArray;
Var                                                                                  //Method
  BankToLowestGold,BankToHighGold,LowToHighGold,LowGoldToCoal: TPointArray;
  Paths: T2DPointArray;
Begin
  If Debug Then
    FunctionStop:= 'LRCPATHS: Entered';

  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  BankToLowestGold:= [Point(198,226), Point(210,238), Point(210,258), Point(214,286), Point(226,314), Point(242,338), Point(257,369)];

  BankToHighGold:= [Point(198,226), Point(210,270), Point(174,290), Point(142,294)];

  LowToHighGold:= [Point(257,369), Point(218,318), Point(170,306), Point(142,294)];

  LowGoldToCoal:= [Point(257,369), Point(242,338), Point(234,314), Point(238,302)];

  Paths:= [BankToLowestGold, BankToHighGold, LowToHighGold, LowGoldToCoal];

  Case Which of
    1: Result:= Paths[0];
    2: Result:= Paths[1];
    3: Result:= Paths[2];
    4: Result:= Paths[3];
  End;

  If Invert Then
  Begin
    InvertTPA(Result);
  End;

  If Debug Then
    FunctionStop:= 'LRCPATHS: Finished';
End;

Procedure MovingSafe;
Var                                                                  //Method
  T:TTimeMarker;
Begin
  T.Start;
  Repeat
    CheckStuff;
    If Not Minimap.IsFlagPresent Then
      Wait(RandomRange(600,800));
    If Not Minimap.IsFlagPresent Then
      Break;
  Until ((Not(Minimap.IsPlayerMoving)) Or (T.GetTime > 12000));
End;

Function Runaways: Boolean;
Var
  FailRest: Integer;
  T: TTimeMarker;
Begin
  If Debug Then
    FunctionStop:= 'Runaways: Entered';

  Result:=False;
  CheckStuff;
  If Not IsLoggedIn Then
    Exit;

  If OldHP <= HPPercent Then
  Begin
    If Debug Then
      Writeln('Gained some HP');
    If OldHP <> -1 Then
    Begin
      If Debug Then
        Writeln('Old HP level: '+ToStr(OldHP));
      OldHP:=HPPercent;
      If Debug Then
        Writeln('New HP level: '+ToStr(OldHP));
      Exit;
    End;
  End Else
    If Debug Then
      Writeln('Lost some HP');

  If Debug Then
    Writeln('Old HP level: '+ToStr(OldHP));
  OldHP:=HPPercent;
  If Debug Then
    Writeln('New HP level: '+ToStr(OldHP));

  If ((HPPercent < (80))) Then
  Begin
    If HPPercent=-1 Then
      Exit;
    OldHP:=HPPercent;
    Writeln('HP LOW '+ToStr(HPPercent)+' RUNNING AWAY');

    Writeln('HP Threshold '+ToStr((80)));              //Method

    If (Spot = 1) Or (Spot = 3) Then
    Begin
      If Debug Then
        Writeln('Running from low spots');
      If Not SPS.WalkPath(LRCPaths(1, True)) Then
        Exit;
    End Else
    Begin
      If Debug Then
        Writeln('Running from high spot');
      If Not SPS.WalkPath(LRCPaths(2, True)) Then
        Exit;
    End;

    MovingSafe;
    T.Start;
    Repeat
      Wait(Random(1000));
      If (T.GetTime>6000) Or (Not IsLoggedIn) Then
        Break;
    Until Not Minimap.IsPlayerMoving;

    If Debug Then
      Writeln('Checking if Monster is still there');

    If Not AtBank Then
      If (Spot = 1) Or (Spot = 3) Then
      Begin
        If Debug Then
          Writeln('Running from low spots');
        SPS.WalkPath(LRCPaths(1, True));
      End Else
      Begin
        If Debug Then
          Writeln('Running from high spot');
        SPS.WalkPath(LRCPaths(2, True));
      End;

    Result := True;

    Wait(RandomRange(5000,6000));

    If RunPercent < 50 Then
    Begin
      If Debug Then
        Writeln('Low energy resting');
      Setrest;
      Repeat
        Timeout.Reset;
        Timeout.Start;
        Timeout2.Reset;
        Timeout2.Start;
        Wait(100);
        CheckStuff;
        If Not IsLoggedIn Then
          Exit;
        If Not SetRest Then
          Inc(FailRest);
        If FailRest>5 Then
          Exit;
      Until RunPercent >= 90;
      Minimap.ToggleRun(True);
    End;

    If (HPPercent > (69)) Then
    Begin
      Writeln('HP IS '+ToStr(HPPercent));
      Writeln('HP > Wait Threshold of '+ToStr((69)));              //Method
      Exit;
    End;

    SetRest;

    If Debug Then
        Writeln('Waiting to heal');

    Repeat
      Wait(RandomRange(20000,40000));
      SmallRandomMouse;                                                 //Method
      CheckStuff;
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
      If Not IsLoggedIn Then
        Break;
    Until((HPPercent > (69)));

    If Debug Then
      Writeln('All healed');
  End;
  If Debug Then
    FunctionStop:= 'Runaways: finished';
End;

Procedure Moving;
Var                                                                //Method
  T: TTimeMarker;
Begin
  T.Start;
  Repeat
    CheckStuff;
    If Runaways Then
      Exit;
    If (Not Minimap.IsFlagPresent) And (Minimap.IsPlayerMoving) Then
      Wait(RandomRange(1400,1700));
    If Not Minimap.IsFlagPresent Then
      Break;
    If Not IsLoggedIn Then
      Break;
  Until ((Not(Minimap.IsPlayerMoving)) Or (T.GetTime > 12000));
End;

Function LowGold: Integer;
Var
  CTS,Count: Integer;
Begin
  If Not IsLoggedIn Then
    Exit;                        //1400

  CTS := GetToleranceSpeed;
  SetColorToleranceSpeed(2);                      //100      75       50        25         0
                                                  //429     383      302       263       149
  SetToleranceSpeed2Modifiers(0.07,0.20);
  Result:= CountColorTolerance(4088954,IntToBox(210,210,274,256),8);
  SetColorToleranceSpeed(CTS);
  SetToleranceSpeed2Modifiers(0.2,0.2);
End;

Function GoldDTMs: Boolean;
Var
  I: Integer;
  T: TTimeMarker;
Begin
  Result:=False;

  T.Start;
  For I:=0 To 1 Do                                                    //Method
  Begin
    Case Spot Of
      1:
      Begin
        If LowGold> 420 Then
        Begin
          Result:=True;
          GoldX:=246;
          GoldY:=204;
        End;
        Exit;
      End;
      2:
      Begin
        A:=105;  B:=44;   C:=400;  D:=325;
        Case I Of
          0: SpotDTM := DTMFromString('m6wAAAHic42ZgYEgD4kAgjgTiFCBOBeJSIM4HYl8gzgHiaiAuAGJ7IPYG4mAg9gRiYyi2BGIzKNsKiPWBuDjOkqEi2YahPdeFoTXbGUynh5owuJhJMzRlOjG05jgz1KbaM/jYyDHwAtUTixlJwEgAAAbREw8=');
          1: SpotDTM := DTMFromString('mrAAAAHic42BgYNBmZGCwBGIrIDYAYhkgVgNifSDmB2JXoBorIHYAYl8g9gPiACC2BWI7IE4PMWZwM5dm8LSSZWjNcWYoS7RmKIqzYGgDshszHRl4gWrwYUYCGAYAo0ELyA==');
        End;
      End;
      3:
      Begin
        A:=Mainscreen.X1; B:=Mainscreen.Y1+20; C:=Mainscreen.X2; D:=292;
        Case I Of
          0: SpotDTM := DTMFromString('mwQAAAHic42RgYLjGyMBwCIgvA/EjIH4JxKJMDAyXgPRjIL4NxGFAddFA7A3EwUAcBcQhQBwHxKlA7A/ERbHWDNkR5gzVafYMLbkuDHWZTgyTK30YyhLtGGrSHRkqku0ZeIDqCGFGIjAcAABphRSg');
          1: SpotDTM := DTMFromString('mrAAAAHic42BgYPBiYWCwBGJPII4A4jYgTgHiMCCWAeLXDBB8H4ifAPELIP4JxH+B+BsQR7krMzRkODKUJ9ow1KbaMbTmODMUxlowVCbbMJQn2DDwANXgw4wEMAwAAC6VEwQ=');
        End;
      End;
    End;

    If FindDTM(SpotDTM,GoldX,GoldY,A,B,C,D) Then                  //Method
    Begin
      Result:=True;
      If Debug Then
        Writeln('Found Gold spot DTM for I='+ToStr(I));
      FreeDTM(SpotDTM);
      If Debug Then
        Writeln ('DTM search completed in '+  IntToStr(T.GetTime) + ' msec');
      Exit;
    End;
    FreeDTM(SpotDTM);
  End;
  If Debug Then
    Writeln ('DTM search completed in '+  IntToStr(T.GetTime) + ' msec');
End;

Function FindGoldDTM: Boolean;
Begin
  Result:=False;
  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If TabBackpack.IsFull Then
  Begin                                                          //Method
    Result := True;
    Exit;
  End;

  If Debug Then
    Writeln('Searching Spot: ' +tostr(Spot));

  If WaitFunc(@GoldDTMs,1,RandomRange(2500,4000)) Then
  Begin
    Mouse(Point(GoldX+GaussRangeInt(-5,5),GoldY+GaussRangeInt(-5,5)),Mouse_Move,Mouse_Accurate);
    If (IsMouseOverText(['posit','neral','depo'],RandomRange(1000,1200))) Then
    Begin
      If Debug Then
        Writeln('Found ore, clicking');
      FastClick(Mouse_Left);
      Wait(RandomRange(500,600));
      Result:=True;
    End Else
      takescreenshot('boom.bmp');
  End Else
    TakeScreenshot('Fail.bmp');
End;



Function Bank: Boolean;
Var
  H,I,CTS: Integer;
  X,Y: Integer;
  ChestBox: TBox;
  TPA,TPA2: TPointArray;
  ATPA: T2DPointArray;
  TBA: TBoxArray;
  MBP: TPoint;                                            //Method
Begin
  If Debug Then
    FunctionStop:= 'Bank: Entered';

  Result:=False;

  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If (Not FindDTM(GoldDTM, X, Y, TabBackpack.GetBounds)) And (Not FindDTM(BarDTM, X, Y, TabBackpack.GetBounds)) And (Not FindDTM(CoalDTM, X, Y, TabBackpack.GetBounds)) Then
    Exit;

  GetMousePos(X,Y);

  If PointInBox(Point(X,Y),Minimap.GetBounds) Then
    TabBackpack.MouseSlot(RandomRange(6,10),Mouse_Move);


  If FindDTM(GoldDTM, X, Y, TabBackpack.GetBounds) Then
  Begin
    If Debug Then
      Writeln('Found Gold in inventory, clicking');


                                                                 //Method
    Mouse(Point(X+GaussRangeInt(-5,5),Y+GaussRangeInt(-5,5)),Mouse_Move,Mouse_Human);
    FastClick(Mouse_Left);

    If (TabBackpack.CountDTM(GoldDTM) = 1) Then
    Begin
      OneOre:=1;
      If Debug Then
        Writeln('Only 1 gold ore found');
    End;
  End Else
  Begin
    If FindDTM(CoalDTM, X, Y, TabBackpack.GetBounds) Then
    Begin
      If Debug Then
        Writeln('Found coal in inventory, clicking');
                                                                 //Method
      Mouse(Point(X+GaussRangeInt(-5,5),Y+GaussRangeInt(-5,5)),Mouse_Move,Mouse_Human);
      FastClick(Mouse_Left);

      If (TabBackpack.CountDTM(CoalDTM) = 1) Then
      Begin
        OneOre:=1;
        If Debug Then
          Writeln('Only 1 coal ore found');
      End;
    End Else
    Begin
      If FindDTM(BarDTM, X, Y, TabBackpack.GetBounds) Then
      Begin
        If Debug Then
          Writeln('Found bar in inventory, clicking');
                                                                   //Method
        Mouse(Point(X+GaussRangeInt(-5,5),Y+GaussRangeInt(-5,5)),Mouse_Move,Mouse_Human);
        FastClick(Mouse_Left);

        If (TabBackpack.CountDTM(BarDTM) = 1) Then
        Begin
          OneOre:=1;
          If Debug Then
            Writeln('Only 1 gold bar found');
        End;
      End Else
        Exit;
    End;
  End;                                                            //Method

  If (ChooseOption.OptionsExist(['Exam','mine','Examine','Canc','ncel','Cancel'],400)) Then
  Begin
    If Debug Then
      Writeln('Closing options menu');
    MouseBox(TabBackpack.GetBounds,Mouse_Move);
  End;

  CTS := GetToleranceSpeed;
  SetColorToleranceSpeed(2);

  SetToleranceSpeed2Modifiers(0.05,0.46);
  FindColorsSpiralTolerance(MainScreen.PlayerPoint.X,MainScreen.PlayerPoint.Y,TPA,6392224,MainScreen.GetBounds.X1,MainScreen.GetBounds.Y1,MainScreen.GetBounds.X2,MainScreen.GetBounds.Y2,5);
  SetColorToleranceSpeed(CTS);
  SetToleranceSpeed2Modifiers(0.2,0.2);

  ATPA := TPAtoATPAEx(TPA,15,25);
  SortATPAFromFirstPointY(ATPA,Point(330,200));

  If (Length(ATPA) = 0) Then
  Begin
    If Debug Then
      Writeln('No booth found.');
    Exit;
  End;

  If Debug Then
    Try
      debugATPA(ATPA);
    Except
      Writeln('Box out of bounds');
    End;

  H := High(ATPA);

  For I:= 0 To H Do
  Begin
    If (Length(ATPA[I]) < 10) Or (Length(ATPA[I]) > 150)  Then
      Continue;

    If Debug Then
      Writeln('Small Chest Length: '+ToStr(Length(atpa[i]))+' for I:= '+ToStr(I));

    ChestBox := GetTPABounds(ATPA[I]);

    With ChestBox Do
    Begin
      If Not IsLoggedIn Then
        Exit;

      SetColorToleranceSpeed(2);
      SetToleranceSpeed2Modifiers(0.11,0.20);
      FindColorsSpiralTolerance(MainScreen.PlayerPoint.X,MainScreen.PlayerPoint.Y,TPA2,8950425,Max(ChestBox.X1-40,0),Max(ChestBox.Y1-5,0),Min(ChestBox.X2+10,Mainscreen.X2),Min(ChestBox.Y2+20,Mainscreen.Y2),18);
      SetColorToleranceSpeed(CTS);
      SetToleranceSpeed2Modifiers(0.2,0.2);

      If Debug Then
        Writeln('Silver Chest Length: '+ToStr(Length(TPA2))+' for I:= '+ToStr(I));

      If Length(TPA2) > 5 Then
      Begin
        SetArrayLength(TBA, Length(TBA)+1);
        ChestBox := IntToBox(Max(ChestBox.X1,0),Max(ChestBox.Y1,0),Min(ChestBox.X2,Mainscreen.X2),Min(ChestBox.Y2,Mainscreen.Y2));
        TBA[High(TBA)] := ChestBox;
      End;
    End;
  End;

  If Debug Then
  Try
    SmartImage.Clear;
    SmartImage.DrawBoxes(TBA, False, clRed);
  Except
    Writeln('Failed Drawing Boxes.');
  End;

  SetLength(TPA,0);
  SetLength(ATPA,0);
  SetLength(TPA2,0);

  For H := 0 To High(TBA) Do
  Begin
    MBP := MiddleBox(TBA[H]);

    If (ChooseOption.OptionsExist(['Exam','mine','Examine','Canc','ncel','Cancel'],400)) Then
    Begin
      If Debug Then
        Writeln('Closing options menu');
      MouseBox(TabBackpack.GetBounds,Mouse_Move);
    End;

    MBP := MiddleBox(TBA[H]);

    Mouse(Point(MBP.X+GaussRangeInt(-5,6),MBP.Y+GaussRangeInt(-10,10)),Mouse_Move,Mouse_Human);

    If (IsMouseOverText(['^ Pu','^ Pull','-^ Pu','-> Pu'],300)) Then
    Begin
      If Debug Then
        Writeln('Found chest, Clicking.');
      If Not SafeBank Then
      Begin
        If DidClick(True) Then
        Begin                                                        //Method
          Result:=True;
          SetArrayLength(ATPA,0);
          SetLength(TPA,0);
          Exit;
        End Else
        Begin
          SetArrayLength(ATPA,0);
          SetLength(TPA,0);
          Exit;
        End;
      End Else
      Begin
        FastClick(Mouse_Right);

        If ChooseOption.Select(['Use','Gold','old', 'ore', 'bar'],RandomRange(400,500)) Then
        Begin
          If Debug Then
            Writeln('Found option to use box');
          Result := True;
          SetArrayLength(ATPA,0);
          SetLength(TPA,0);
          Exit;
        End Else
        Begin                                                        //Method
          If Debug Then
            Writeln('DIDNT FIND OPTION TO DEPOSIT');
          MouseBox(TabBackpack.GetBounds,Mouse_Left);
          SetArrayLength(ATPA,0);
          SetLength(TPA,0);
          Exit;
        End;
      End;
    End;
  End;
  SetLength(ATPA,0);
  SetLength(TPA,0);
  If Debug Then
    FunctionStop:= 'Bank: Finished';
End;


Function ToBank: Boolean;
Var
  X,Y: Integer;
  P: TPoint;
Begin
  If Debug Then
    FunctionStop:= 'ToBank: Entered';
                                                                   //Method
  Result:=False;

  If AtBank Then
  Begin
    Result:=True;
    Exit;
  End;

  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If (Spot = 1) Or (Spot = 3) Then
  Begin
    If Debug Then
      Writeln('Walking to bank from lower spots');
    SPS.WalkPath(LRCPaths(1, True));
  End Else
  Begin
    If Debug Then
      Writeln('Walking to bank from higher spot');
    SPS.WalkPath(LRCPaths(2, True));
  End;

  CheckStuff;
  Moving;

  If Minimap.FindSymbol(P,MM_SYMBOL_BANK,Minimap.GetBounds) Then
  Begin
    Timeout.Reset;
    Timeout.Start;
    Timeout2.Reset;
    Timeout2.Start;
    Result := True;                                                //Method
    If Debug Then
      Writeln('Found bank symbol');
  End Else
    If Debug Then
      Writeln('No bank symbol found');

  If Debug Then
    FunctionStop:= 'ToBank: Finished';
End;

Procedure Banking;
Var
  I,X,Y: Integer;
  T: TTimeMarker;
  Coal: Boolean;
Begin
  If Debug Then
    FunctionStop:= 'Banking: Entered';
                                                                         //Method
  SafeBank:=False;

  CheckStuff;

  If Not IsLoggedIn Then
    Exit;


  If Not ToBank Then
  Begin
    Writeln('Did not get to bank, logging in and out to reset map');
    Players[CurrentPlayer].ExitToLobby;
    Wait(RandomRange(2500,3500));

    If Debug Then
      Writeln('Loging back in');

    Players[CurrentPlayer].Login;
    Wait(RandomRange(2500,3500));
    CheckStuff;                                                                    //Method
    Minimap.ClickCompass;
    MainScreen.SetAngle(MS_ANGLE_HIGH);
    ToBank;
  End;

  For I:=0 to 2 Do
  Begin
    If Debug Then
      Writeln('Banking '+ToStr(I)+' times');

    If (Not FindDTM(GoldDTM, X, Y, TabBackpack.GetBounds)) And (Not FindDTM(BarDTM, X, Y, TabBackpack.GetBounds)) And (Not FindDTM(CoalDTM, X, Y, TabBackpack.GetBounds)) Then
      Exit;

    If TabBackpack.IsEmpty Then
      Exit;

    If WaitFunc(@Bank,100,4000) Then
    Begin
      If Debug Then                                                                  //Method
        Writeln('Clicking back success');

      T.Start;
      Repeat
        Wait(Random(100));
        If Not IsLoggedIn Then
          Exit;
        If T.GetTime > 5000 Then
        Begin
          If Debug Then
            Writeln('Chat text timeout, trying to bank again');
          SafeBank:=True;
          Bank;
          Wait(RandomRange(4000,6000));                                                       //Method
        End;

        If OneOre=1 Then
        Begin
          If Debug Then
            Writeln('Only one ore skipping npc chat wait');
          Break;
        End;

        If T.GetTime > 15000 Then
        Begin
          If Debug Then
            Writeln('No chat in 15 seconds, giving up');
          Break;
        End;
      Until (ConversationBox.IsOpen);

      If Not (OneOre=1) Then
      Begin
        If Debug Then
          Writeln('Depositing '+ToStr(TabBackpack.CountDTM(GoldDTM))+' Gold');

        If (TabBackpack.CountDTM(GoldDTM) < 6) And (TabBackpack.CountDTM(GoldDTM) > 2) Then           //Method
          TypeSend('3',False) Else
        If (TabBackpack.CountDTM(GoldDTM) < 3) And (TabBackpack.CountDTM(GoldDTM) > 0) Then
          TypeSend('2',False) Else
        If TabBackpack.CountDTM(GoldDTM) > 5 Then
          TypeSend('4',False);

        If TabBackpack.CountDTM(GoldDTM) =0 Then
        Begin
          If Debug Then
            Writeln('No gold found, depositing '+ToStr(TabBackpack.CountDTM(CoalDTM))+' coal');

          If (TabBackpack.CountDTM(CoalDTM) > 0) Then                                                    //Method
            Coal:=True;

          If (TabBackpack.CountDTM(CoalDTM) < 6) And (TabBackpack.CountDTM(CoalDTM) > 2) Then
            TypeSend('3',False) Else
          If (TabBackpack.CountDTM(CoalDTM) < 3) And (TabBackpack.CountDTM(CoalDTM) > 0) Then
            TypeSend('2',False) Else
          If TabBackpack.CountDTM(CoalDTM) > 5 Then
            TypeSend('4',False);
        End;

        If (Not FindDTM(GoldDTM, X, Y, TabBackpack.GetBounds)) And (Not FindDTM(CoalDTM, X, Y, TabBackpack.GetBounds)) Then
        Begin
          If Debug Then
            Writeln('Depositing '+ToStr(TabBackpack.CountDTM(BarDTM))+' Gold Bars');

          If (TabBackpack.CountDTM(BarDTM) < 6) And (TabBackpack.CountDTM(BarDTM) > 2) Then           //Method
            TypeSend('3',False) Else
          If (TabBackpack.CountDTM(BarDTM) < 3) And (TabBackpack.CountDTM(BarDTM) > 0) Then
            TypeSend('2',False) Else
          If TabBackpack.CountDTM(BarDTM) > 5 Then
            TypeSend('4',False);
        End;
      End;
                                                                                                      //Method
      TabBackpack.WaitForShift(4000);

      Coal:=False;

      If Debug Then
        Writeln('Making sure gold dtm is set to gold ore');

      FreeDTM(GoldDTM);
      GoldDTM:= DTMFromString('mWAAAAHicY2FgYJjBxMDQB8SzgHgxEAcyMjAEAbEHEHsD8eZ+KYZEPzOGTb2SDJkh1gz8QD3ImBENgwAA4fkIew==');  //goldore
    End Else
      SafeBank:=True;
                                                                                                //Method
    If Debug Then
      Writeln('One ore variable back to 0');
    OneOre:=0;
  End;
  If Debug Then
    FunctionStop:= 'ToBank: Finished';
End;

Procedure RandomizePoints(TPA: TPointArray);
Var
  L,LL: Integer;
begin
  L:= High(TPA);
  LL:= L;                                                 //Method
  While (L > 1) do
  begin
    TSwap(TPA[Random(LL)], TPA[Random(LL)]);
    Dec(L);
  end;
end;

Procedure DownloadImage(ImageName: String; Location: String);
var
  Image, Path: string;                                      //Method
  FP: Integer;
begin
  Image:= GetPage(Location);
  Path:= IncludePath + 'SPS\img\runescape_surface\' + ImageName + '.png';
  Path:= Trim(Path);
  FP:= CreateFile(Path);
  WriteFileString(FP, Image);
  CloseFile(FP);                                             //Method
end;

Function GrabMaps: Boolean;
var
  LRCMap: String;    //Map Locations
  LRCName: String;      //Map Names
begin
  LRCName:= '0_0LRC';                                      //Method
  LRCMap:= 'http://i.imgur.com/gcG83.png';
  if DMP then
  begin
    if (Not FileExists(IncludePath + 'SPS\img\runescape_surface\0_0LRC.png')) then
    begin
      writeln('You did not download SPS image correctly');
      writeln('It must go here: '+ToStr(IncludePath) + 'SPS\img\runescape_surface\0_0LRC.png');
      TerminateScript;
    end;
  end;
  Result:= (FileExists(IncludePath + 'SPS\img\runescape_surface\0_0LRC.png'));
end;

Procedure RequirementsCheck;
begin
  If (Not GrabMaps) then
    RaiseException(erCustomError, 'SPS Maps Do Not Exist OR They Are Named Incorrectly!');
end;

Function FindDTMSlot(var X, Y: Integer; DTM, Slot: Integer): Boolean;
Var
  Bounds: TBox;
Begin
  Bounds:= TabBackpack.GetSlotBox(Slot);
  Result:= FindDTM(DTM, X, Y, Bounds.X1, Bounds.Y1, Bounds.X2, Bounds.Y2);
End;

Procedure DropLRCBackup;
Var
  I, Bars, X, Y: Integer;
Begin
  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  TabBackpack.Open;
  TabBackpack.ClickDTM(GoldDTM,Mouse_Right,'rop');
  TabBackpack.ClickDTM(CoalDTM,Mouse_Right,'rop');
  TabBackpack.ClickDTM(Bars,Mouse_Right,'rop');
end;

Procedure DropLRC(GoldOres,GoldBars,CoalOres: Boolean);
Var
  X, Y,Invs: Integer;
  T,TT: TTimeMarker;
Begin
  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If Not ActionBars Then
  Begin
    DropLRCBackup;
    Exit;
  End;

  TabBackpack.Open;
  if (FindDTM(GoldDTM, X, Y, TabBackpack.GetBounds)) And (GoldOres) then
  begin
    If Debug Then
      Writeln('Found GoldDTM');
    OreCount := OreCount + TabBackpack.CountDTM(GoldDTM);
    T.Start;
    TT.Start;
    Invs:=TabBackpack.Count;
    Repeat
      If T.GetTime> 10000 Then
      Begin
        DropLRCBackup;
        Break;
      End;
      If TT.GetTime > 5000 Then
      Begin
        TypeByte(VK_ENTER);
        Wait(RandomRange(500,600));
        TypeByte(VK_ESCAPE);
        TypeByte(VK_ESCAPE);
        TT.Reset;
        TT.Start;
      End;
      If TabBackpack.Count<Invs Then
      Begin
        T.Reset;
        T.Start;
        Invs:=TabBackpack.Count;
        If Debug Then
          Writeln('Inv Decreased');
      End;
      Wait(Random(100));
      ConversationBox.Continue(True,True);
      TypeSend(GoldOre,False);
      Wait(RandomRange(0,100));
    Until Not (FindDTM(GoldDTM, X, Y, TabBackpack.GetBounds));
  end;
  if (FindDTM(BarDTM, X, Y, TabBackpack.GetBounds)) And (GoldBars) then
  begin
    If Debug Then
      Writeln('Found BarDTM');
    OreCount := OreCount + TabBackpack.CountDTM(BarDTM);
    T.Reset;
    T.Start;
    TT.Reset;
    TT.Start;
    Invs:=TabBackpack.Count;
    Repeat
      If T.GetTime> 10000 Then
      Begin
        DropLRCBackup;
        Break;
      End;
      If TT.GetTime > 5000 Then
      Begin
        TypeByte(VK_ENTER);
        Wait(RandomRange(500,600));
        TypeByte(VK_ESCAPE);
        TypeByte(VK_ESCAPE);
        TT.Reset;
        TT.Start;
      End;
      If TabBackpack.Count<Invs Then
      Begin
        T.Reset;
        T.Start;
        Invs:=TabBackpack.Count;
      End;
      Wait(Random(100));
      ConversationBox.Continue(True,True);
      TypeSend(GoldBar,False);
      Wait(RandomRange(0,100));
    Until Not (FindDTM(BarDTM, X, Y, TabBackpack.GetBounds));
  end;
  if (FindDTM(CoalDTM, X, Y, TabBackpack.GetBounds)) And (CoalOres) then
  begin
    If Debug Then
      Writeln('Found Coal to drop');
    OreCount := OreCount + TabBackpack.CountDTM(CoalDTM);
    T.Reset;
    T.Start;
    TT.Reset;
    TT.Start;
    Invs:=TabBackpack.Count;
    Repeat
      If T.GetTime> 10000 Then
      Begin
        DropLRCBackup;
        Break;
      End;
      If TT.GetTime > 5000 Then
      Begin
        TypeByte(VK_ENTER);
        Wait(RandomRange(500,600));
        TypeByte(VK_ESCAPE);
        TypeByte(VK_ESCAPE);
        TT.Reset;
        TT.Start;
      End;
      If TabBackpack.Count<Invs Then
      Begin
        T.Reset;
        T.Start;
        Invs:=TabBackpack.Count;
      End;
      Wait(Random(100));
      ConversationBox.Continue(True,True);
      TypeSend(CoalOre,False);
      Wait(RandomRange(0,100));
    Until Not (FindDTM(CoalDTM, X, Y, TabBackpack.GetBounds));
  end;
  ProgressReport;
end;

Function WaitFindDTM(DTM: Integer; Time: Integer = 500): Boolean;
Var
  T: TTimeMarker;
  X,Y: Integer;
Begin
  T.Start;
  Repeat
    Result:= FindDTM(DTM, X, Y, TabBackpack.GetBounds);
    Wait(100);
  Until (Result) Or (T.GetTime > Time);
End;

Procedure StaffRuneCheck;
Var
  FireRune, NatureRune, X, Y: Integer;
begin
  FireRune:= DTMFromString('mggAAAHicY2NgYPBiYmDwZ4LQIVAMYv8Dyv0HYiZGBgZWRgibA0jPlBeF487mZoZJPd0MQf7+DFxAeWyYEQeGAAC7yQvH');
  NatureRune:= DTMFromString('mggAAAHicY2NgYDjJxMBwFIjPAfFFID4LxMeBmJERKAnEP4DUPyBmZ4RgwToROG5vbGTISU9niI2MZOACqsGGGXFgCAAAbHcM2g==');
  TabBackpack.Open;

  If Not SFS Then
    HeatAlch:= ((WaitFindDTM(FireRune)) and WaitFindDTM(NatureRune)) Else     //returns true if it doesn't find either of these
    HeatAlch:= (WaitFindDTM(NatureRune));

  FreeDTM(FireRune);
  FreeDTM(NatureRune);
end;

{Procedure AlchOresBackup(BankBars: Boolean);
Var
  Spell,X,Y,Count: Integer;
begin
  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  StaffRuneCheck;

  If (Not HeatAlch) Then
  Begin
    BankBars:= JIC;
    If (BankBars) Then
    Begin
      Method:=0;
    End Else
      Method:=1;
    Exit;
  End;

  Spell := DTMFromString('mggAAAHicY2NgYHBmYmAwBWIzKPYDYn8g3sDIwLAYiFcB8WYoexsQK6YZMVxZY8OwZYI2w8np2gxOVgZgzA80CxtmxIEhAAAKJQzK');
  TabBackpack.Open;
  Count:= TabBackpack.CountDTM(GoldDTM);

  While (Count > 0) do
  begin
    If RunAways Then
      Break;

    if (Not Tab_Magic.Open) then
      Exit;

    If (Not FindDTM(Spell,X, Y, TabBackpack.GetBounds)) And (GetCurrentTab=Tab_Magic) Then
    Begin
      HumanMouseBox(702,302-50,721,322-50);
      FastClick(Mouse_Left);
    End;

    if (WaitFindDTM(Spell,4000)) then
    begin
      HumanMMouse(X, Y, 3, 3);
      if (WaitUptext('ast', 600)) then
        FastClick(Mouse_Left);

      If Not WaitFindDTMEx(GOLDDTM,X, Y, TabBackpack.GetBounds,200, 2000) Then
        WaitFindDTMEx(CoalDTM,X, Y, TabBackpack.GetBounds, MIY2,200, 2000);

      CheckStuff;

      Count:= TabBackpack.CountDTM(GoldDTM);
      HumanMMouse(X, Y, 3, 3);
      if (WaitUptext('ast', 600)) then
      begin
        FastClick(Mouse_Left);
        If Not TabBackpack.IsFull Then
          Wait(randomrange(1900,2200));
      end;
    end else
    begin
      if(IsUptext('umble')) then
        HumanMMouse(MICX, MICY, 0, 0);

      CheckStuff;
    end;
  end;
  TabBackpack.Open;
  FreeDTM(Spell);
end;   }

Function AlchOres(BankBars: Boolean): Boolean;
Var
  Spell,X,Y,Count: Integer;
  T: TTimeMarker;
begin
  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If Not ActionBars Then
  Begin
   // AlchOres(BankBars);
    Method:=0;
    Exit;
  End;

  StaffRuneCheck;

  If (Not HeatAlch) Then
  Begin
    BankBars:= JIC;
    If (BankBars) Then
    Begin
      Method:=0;
    End Else
      Method:=1;
    Exit;
  End;

  Spell := DTMFromString('mggAAAHicY2NgYHBmYmAwBWIzKPYDYn8g3sDIwLAYiFcB8WYoexsQK6YZMVxZY8OwZYI2w8np2gxOVgZgzA80CxtmxIEhAAAKJQzK');
  TabBackpack.Open;
  Count:= TabBackpack.CountDTM(GoldDTM)+TabBackpack.CountDTM(CoalDTM);

  T.Start;
  While (Count > 0) do
  begin
    If RunAways Then
      Break;

    ConversationBox.Continue(True,True);

    TypeSend(Alch,False);
    Wait(RandomRange(30,60));

    If Not FindDTM(GOLDDTM,X, Y, TabBackpack.GetBounds) Then
      If Not FindDTM(CoalDTM,X, Y, TabBackpack.GetBounds) Then
        Break;

    If CheckStuff Then
      Break;

    Count:= TabBackpack.CountDTM(GoldDTM)+TabBackpack.CountDTM(CoalDTM)-1;
    Mouse(X, Y, 3, 3);
    if (IsMouseOverText(['ast'], 600)) then
    begin
      If Debug Then
        Writeln('Found Spell uptext, clicking');
        FastClick(Mouse_Left);
        T.Reset;
        T.Start;
        If Not TabBackpack.IsFull Then
          Wait(randomrange(1900,2200)) Else
          Result:=True;
    end else
    Begin
      If Debug Then
        Writeln('No spell uptext found, hitting enter');
      TypeByte(VK_ENTER);
      Wait(RandomRange(500,600));
      TypeByte(VK_ESCAPE);
    End;
    If T.GetTime>10000 Then
    Begin
     // AlchOresBackup(False);
      Break;
    End;
  End;
  FreeDTM(Spell);
end;

{Procedure SuperHeatBackUp(BankBars: Boolean);
Var
  Spell, X, Y, Count: Integer;
begin
  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If Debug Then
      Writeln('Superheating');

  StaffRuneCheck;

  if (Not HeatAlch) then
  begin
    BankBars:= JIC;
    if (BankBars) then     //Swap the GoldDTM with BarsDTM.. Then Swap them Back..
    begin
      Method:=0;
    end else
      Method:=1;
    exit;
  end;

  Spell := DTMFromString('mWAAAAHicY2FgYJjBxMAwD4inAPF0IO5mZGDoB+IJQNwGxL+2uDP82ajC8OviOob3bU4M/EA9yJgRDYMAALa8DNg=');
  TabBackpack.Open;
  Count:= ItemAmount('inv', 'dtm', GoldDTM, []);

  If Debug Then
    Writeln('FOUND '+ ToStr(Count)+' GOLD ORES');

  While (Count > 0) do
  begin
    If Debug Then
      Writeln('FOUND GOLD ORE, STARTING TO HEAT');

    If RunAways Then
      Break;

    if (Not WaitGameTab(Tab_Magic, 3000)) then
      Gametab(Tab_Magic);

    If (Not FindDTM(Spell,X, Y, TabBackpack.GetBounds)) And (GetCurrentTab=Tab_Magic) Then
    Begin
      HumanMouseBox(702,302-50,721,322-50);
      FastClick(Mouse_Left);
    End;

    if (WaitFindDTMEx(Spell,X, Y, TabBackpack.GetBounds,200, 4000)) then
    begin
      If Debug Then
        Writeln('FOUND SPELL');

      HumanMMouse(X, Y, 3, 3);

      if (WaitUptext('ast', 600)) then
      Begin
        If Debug Then
          Writeln('CLICKING SPELL');
        FastClick(Mouse_Left);
      End;

      If WaitFindDTMEx(GOLDDTM,X, Y, TabBackpack.GetBounds,200, 2000) Then
      Begin
        If Debug Then
          Writeln('FOUND GOLD CLICKING');

        Count:= ItemAmount('inv', 'dtm', GoldDTM, [])-1;

        If Debug Then
          Writeln('FOUND '+ ToStr(Count)+' GOLD ORES');

        CheckStuff;

        HumanMMouse(X, Y, 4, 4);

        if (WaitUptext('ast', 600)) then
        Begin
          If Debug Then
            Writeln('CLICKED');

          FastClick(Mouse_Left);

          If Not TabBackpack.IsFull Then
            Wait(randomrange(1900,2500)) Else
            If (Count=0) And (Method=3) Then
              ToBank;

        End;
      End;
    end else
      CheckStuff;
  End;
  TabBackpack.Open;

  FreeDTM(Spell);

  If Debug Then
    Writeln('FINISHED HEATING');
End;      }

Function SuperHeat(BankBars: Boolean): Boolean;
Var
  Spell, X, Y, Count: Integer;
  T: TTimeMarker;
begin
  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If Not ActionBars Then
  Begin
    //SuperHeatBackup(BankBars);
    Method:=0;
    Exit;
  End;

  If Debug Then
      Writeln('Superheating');

  StaffRuneCheck;

  if (Not HeatAlch) then
  begin
    BankBars:= JIC;
    if (BankBars) then
    begin
      Method:=0;
    end else
      Method:=1;
    exit;
  end;

  Spell := DTMFromString('mWAAAAHicY2FgYJjBxMAwD4inAPF0IO5mZGDoB+IJQNwGxL+2uDP82ajC8OviOob3bU4M/EA9yJgRDYMAALa8DNg=');
  TabBackpack.Open;
  Count:= TabBackpack.CountDTM(GoldDTM);

  If Debug Then
    Writeln('FOUND '+ ToStr(Count)+' GOLD ORES');

  T.Start;
  While (Count > 0) do
  begin
    If Debug Then
      Writeln('FOUND GOLD ORE, STARTING TO HEAT');

    If RunAways Then
      Break;

    ConversationBox.Continue(True,True);

    TypeSend(Superheats,False);
    Wait(RandomRange(30,60));

    If FindDTM(GOLDDTM,X, Y, TabBackpack.GetBounds) Then
    Begin
      If Debug Then
        Writeln('FOUND GOLD CLICKING');

      If Debug Then
        Writeln('FOUND '+ ToStr(Count)+' GOLD ORES');

      If CheckStuff Then
        Break;

      Mouse(X, Y, 4, 4);

      if (IsMouseOverText(['ast'], 600)) then
      Begin
        If Debug Then
          Writeln('Spell active clicking ore');

        Count:= TabBackpack.CountDTM(GoldDTM)-1;
        If Debug Then
          Writeln('Count : '+ToStr(Count));
        FastClick(Mouse_Left);

        T.Reset;
        T.Start;

        If Not TabBackpack.IsFull Then
        Begin
          If Debug Then
            Writeln('Inventory not full yet, going slow');
          Wait(randomrange(1900,2500))
        End Else
          If (Count=0) And (Method=3) Then
          Begin
            If Debug Then
              Writeln('Headed to bank b/c no more ores');
            ToBank;
            Break;
          End Else
            If (Method=4) Then
              Result:=True;
      End Else
      Begin
        If Debug Then
          Writeln('No Uptext found for superheat');
        TypeByte(VK_ENTER);
        Wait(RandomRange(500,600));
        TypeByte(VK_ESCAPE);
        TypeByte(VK_ESCAPE);
      End;
    End;
    If T.GetTime>10000 Then
    Begin
      If Debug Then
        Writeln('Been too long for superheating, trying backup');
    //  SuperHeatBackup(False);
      Break;
    End;
    Wait(Random(200));
  End;
  FreeDTM(Spell);

  If Debug Then
    Writeln('FINISHED HEATING');
End;

Procedure Mining;
Var
  X,Y,BegInv,BegXP,MaxCoal: Integer;
  AniTimer,XPInvTimer: TTimeMarker;
  L, I: Integer;
  P: TPoint;
  B: TBoxArray;
  BMP, BMP2,PixelShifts: TIntegerArray;
Begin
  If Debug Then
    FunctionStop:= 'Mining: Entered';

  If Debug Then
      Writeln('Mining afk');

  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  BegInv:=TabBackpack.Count;
 // BegXP:=GetXPBarTotal;
  AniTimer.Start;
  XPInvTimer.Start;

  MaxCoal:=RandomRange(60000,160000);

  Repeat
    If CheckStuff Then
    Begin
      Wait(RandomRange(5000,6000));
      FindGoldDTM;
      AniTimer.Reset;
      AniTimer.Start;
      XPInvTimer.Reset;
      XPInvTimer.Start;
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
    End;

    Wait(Random(100));

    If Not IsLoggedIn Then
      Break;

    If BegInv<TabBackpack.Count Then
    Begin
      AniTimer.Reset;
      AniTimer.Start;
      XPInvTimer.Reset;
      XPInvTimer.Start;
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
      BegInv:=TabBackpack.Count;
      If Debug Then
        Writeln('Inventory count increased');
    End;

   { If BegXP<GetXPBarTotal Then
    Begin
      MarkTime(XPInvTimer);
      MarkTime(AniTimer);
      BegXP:=GetXPBarTotal;
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
      If Debug Then
        Writeln('Xp increased');
    End;   }

    If Spot=3 Then
      If ((Method = 1) Or (Method = 4)) Then
        If CoalTimer.GetTime>MaxCoal Then
          Break;

    If WaitFunc(@GoldDTMs,1,RandomRange(2000,4000)) Then
    Begin
      AniTimer.Reset;
      AniTimer.Start;
      If Debug Then
        Writeln('Mining animation active');
    End Else
    Begin
      If TabBackpack.IsFull Then
        Break;
      GetMousePos(X,Y);
      If PointInBox(Point(X,Y),IntToBox(162,118,328,303)) Then
      Begin
        MouseOffClient(4,True);
        AniTimer.Reset;
        AniTimer.Start;
      End Else
        If Debug Then
          TakeScreenshot('Fail.bmp');
      If Not GoldDTMs Then
        Break Else
        Begin
          XPInvTimer.Reset;
          XPInvTimer.Start;
          AniTimer.Reset;
          AniTimer.Start;
        End;
    End;

    If Runaways Or Minimap.FindSymbol(P,MM_SYMBOL_BANK,IntToBox(661,83,705,126)) Then
    Begin
      If Debug Then
        Writeln('Found bank symbol');
      Exit;
    End;

    If XPInvTimer.GetTime>RandomRange(14000,15000) Then
    Begin
      If Debug Then
        Writeln('XP/Inv Timeout');
      If Not FindGoldDTM Then
        Break Else
        Begin
          XPInvTimer.Reset;
          XPInvTimer.Start;
        End;
    End;

    If AniTimer.GetTime>RandomRange(1500,2000) Then
    Begin
      If Debug Then
        Writeln('Animation Timeout');
      If Not FindGoldDTM Then
        Break Else
        Begin
          AniTimer.Reset;
          AniTimer.Start;
        End;
      XPInvTimer.Reset;
      XPInvTimer.Start;
    End;

    If (Method=1) And (ActionBars) Then
      If TabBackpack.Count>10 Then
      Begin
        DropLRC(True,True,True);
        BegInv:=TabBackpack.Count;
      End;

    If (Method = 2) then
    Begin
      If AlchOres(JIC) Then
        Break;
      BegInv:=TabBackpack.Count;
    End Else
      If (Method = 3) then
        SuperHeat(True) Else
        If (Method = 4) then
        Begin
          If SuperHeat(False) Then
            Break;
          If TabBackpack.IsFull Then
            Break;
          DropLRC(False,True,True);
          BegInv:=TabBackpack.Count;
        End;

    If (TabBackpack.Count<26) And ((HPPercent > (75))) And (Method<>2) And (Method<>3) And (Method<>4) Then
      AntiBan Else
      MouseOffClient(4,True);
  Until (TabBackpack.IsFull);

  If Debug Then
    Writeln('Inventory is full or spot is gone');

  If Debug Then
    FunctionStop:= 'Mining: Finished';
End;

Function FixPosition: Boolean;
Var
  HighBox: TBox;
Begin
  If Debug Then
    FunctionStop:= 'FixPosition: Entered';

  Result:=False;

  CheckStuff;

  If Not IsLoggedIn Then
    Exit;

  If Spot=1 Then
  Begin
    Off := ToStr(SPS.GetPlayerPos);
    If (Not(Off = '(258,366)')) And (Not(Off = '(254,366)')) And (Not(Off = '(258,366)')) Then
    Begin
      If Debug Then
      Begin
        Writeln('Off of spot, correcting');
        Writeln('Off coordinates: '+Off);
      End;
      SPS.WalkToPos(Point(258,368));
      Result:=True;
    End;
  End Else
  Begin
    HighBox:=IntToBox(126,282,150,298);
    If Not PointInBox(SPS.GetPlayerPos,HighBox) Then
    Begin
      If Debug Then
      Begin
        Writeln('Off of spot, correcting');
        Writeln('Off coordinates: '+Off);
      End;
      SPS.WalkToPos(Point(142,294));
      Result:=True;
    End;
  End;

  If Debug Then
    FunctionStop:= 'FixPosition: Finished';
End;

Procedure Mainloop;
Var
  X,Y: Integer;
  P: TPoint;
Label
  Skip;
Label
  SkipUp;
Label
  SkipDown;
Begin
  If Debug Then
    FunctionStop:= 'MainLoop: Entered';

  CheckStuff;

  If (Not IsLoggedIn) Then
    Exit;

  If TabBackpack.IsFull Then
    If (Method=0) Or (Method=3) Then
      Banking;

  If Debug Then
      Writeln('Empty spot reset to 0');

  EmptySpot:=0;

  If (Spot=1) Or (Spot=3) Then
  Begin
    If Debug Then
      Writeln('Walking to low spot');

    If SPS.WalkPath(LRCPaths(1, False)) Then //bank to low
    Begin
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
      If Debug Then
        Writeln('Made it to low spot');
      Spot:=1;
    End Else
      SPS.BlindWalk(Point(325, 25));
  End Else
  Begin
    If Debug Then
      Writeln('Walking to high spot');

    If SPS.WalkPath(LRCPaths(2, False)) Then //bank to high spot
    Begin
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
      If Debug Then
        Writeln('Arrived at spot 2, high spot');
      Spot:=2;
    End Else
      SPS.BlindWalk(Point(198, -49));
  End;

  Moving;
  FixPosition;


  Repeat
    CheckStuff;
    If Not IsLoggedIn Then
      Exit;
    Wait(Random(100));

    SkipUp:
    If (Spot=1) Then
      If FindGoldDTM Then     //low or high spot
      Begin
        If Debug Then
          Writeln('Found Gold, EmptySpot back to 0');
        EmptySpot:=0;
        Mining;
        BreakHandler(BreakIn,BreakFor,Bir,Bfr);
        If (Not TabBackpack.IsFull) And (Spot=1) Then
          GoTo SkipDown;
      End Else
      Begin
        BreakHandler(BreakIn,BreakFor,Bir,Bfr);
        EmptySpot := EmptySpot + 1;
        If Debug Then
          Writeln('Did not find gold, emptyspot is: '+ToStr(EmptySpot));

        SkipDown:
        If RunPercent < 50 Then
        Begin
          If Debug Then
            Writeln('Run energy low, resting');
          Setrest;
          Repeat
            Timeout.Reset;
            Timeout.Start;
            Timeout2.Reset;
            Timeout2.Start;
            If Runaways Then
              Exit;
            CheckStuff;
            If Not IsLoggedIn Then
              Exit;
            setrest;
            wait(100);
          Until RunPercent > 90;
          Minimap.ToggleRun(True);

          If Debug Then
            Writeln('Run energy restored');

          GoTo SkipUp;
        End;
        CheckStuff;

        If EmptySpot >= 2 Then
        Begin
          If Debug Then
            Writeln('EmptySpot too high, going to look for coal');

          If SPS.WalkPath(LRCPaths(4, False)) Then
            Spot:=3 Else
            SPS.BlindWalk(Point(309, -38));

          Moving;

          If FindGoldDTM Then
          Begin
            If Debug Then
              Writeln('Found coal');
            CoalTimer.Reset;
            CoalTimer.Start;
            Mining;
          End;

          If TabBackpack.IsFull Then
            Break;

          EmptySpot:=0;
        End;

        If Debug Then
            Writeln('Walking to high spot');

        If SPS.WalkPath(LRCPaths(3, False)) Then //low to high spot
        Begin
          Spot:=2;
          If Debug Then
            Writeln('Arrived at spot 2, high spot');
        End Else
          Exit;

        Moving;
        FixPosition;
      End;

      If Spot=2 Then
        If FindGoldDTM Then  //high spot
        Begin
          If Debug Then
            Writeln('Found gold, emptyspot back to 0');
          EmptySpot:= 0;
          Mining;
          If Not TabBackpack.IsFull Then
            GoTo Skip;
        End Else
        Begin
          Skip:
            EmptySpot:= EmptySpot + 1;
            If Debug Then
              Writeln('Did not find gold, emptyspot is '+ToStr(EmptySpot));
            CheckStuff;

            If Debug Then
                Writeln('Walking from high to low spot');

            If SPS.WalkPath(LRCPaths(3, True)) Then  //high to low spot
            Begin
              Timeout.Reset;
              Timeout.Start;
              Timeout2.Reset;
              Timeout2.Start;
              If Debug Then
                Writeln('Arrived at spot 1, low spot');
              Spot := 1;
            End Else
              Exit;
          Moving;
          FixPosition;
        End;
  Until ((TabBackpack.IsFull) Or (Minimap.FindSymbol(P,MM_SYMBOL_BANK,Minimap.GetBounds)));

  If (Method = 3) Then
  Begin
    SuperHeat(True);
  End;

  ProgressReport;
  If ((Method = 0) Or (Method = 3)) Then
  Begin
    If Debug Then
      Writeln('Banking for method '+ToStr(Method));
    Banking;
  End Else
    If ((Method = 1) Or (Method = 4)) Then
    Begin
      If Debug Then
        Writeln('Dropping for method '+ToStr(Method));
      If (Method = 4) Then
        SuperHeat(False);
      DropLRC(True,True,True);
      FindGoldDTM;
    End Else
      If (Method = 2) Then
        AlchOres(JIC);

  If RunPercent < 50 Then
  Begin
    If Debug Then
      Writeln('Low energy resting');
    Setrest;
    Repeat
      Timeout.Reset;
      Timeout.Start;
      Timeout2.Reset;
      Timeout2.Start;
      Wait(100);
      If Runaways Then
        Exit;
      CheckStuff;
      If Not IsLoggedIn Then
        Exit;
      setrest;
    Until RunPercent > 90;
    Minimap.ToggleRun(True);
  End;
  If Debug Then
    FunctionStop:= 'MainLoop: Finished';
End;

Procedure LastRun;
Begin
  Writeln(FunctionStop);
End;

Procedure Setup;
Var
X,Y: Integer;
Begin
  If Debug Then
    FunctionStop:= 'Setup: Entered';

  ClearDebug;
  RequirementsCheck;
  AutoUpdateMe;

  SetupSRL;
  StatsSetup(944, SRLStats_Username, SRLStats_Password);

  If Not Debug Then
    DisableSRLDebug:=True;

  DeclarePlayers;
  If Not Players[CurrentPlayer].Login Then
    TerminateScript;

  Writeln('If you changed more than one character in the script to fix the antileech, you are wrong and probably broke something :)');
  SPS.Setup('0_0LRC', 'Runescape_Surface\');
  Minimap.ClickCompass;
  MainScreen.SetAngle(MS_ANGLE_HIGH);
  Players[CurrentPlayer].FindMod := False;
  //ToggleXPBar(True);
  //StartingExperience:=GetXPBarTotal;
  If FindNormalRandoms Then
    Wait(RandomRange(2000,3000));

  Case PTS Of
    1: NewPouch:=61;  //titan
    2: NewPouch:=55;  //golem
  End;

  {If UsingFamiliar Then
    SummoningTimer:=(GetSystemTime-((NewPouch-GetNPCTimer)*60*1000)) Else
    NoFamiliar:=True; }
  //HP:=GetMaxHP;
  OldHP:=HPPercent;
  Spot:=1;
  Timeout.Reset;
  Timeout.Start;
  Timeout2.Reset;
  Timeout2.Start;

  StartTime:=GetSystemTime;

  AddOnTerminate('F33DTM');
  If Debug Then
    AddOnTerminate('LastRun');
  SetDTM;

 { If ((Method = 2) Or (Method = 3) Or (Method = 4)) Then
  Begin
    TabBackpack.Open;

    If SFS Then
    Begin
      If FindDTM(Staff, X, Y, TabBackpack.GetBounds) Then
      Begin
        Mouse(X,Y,0,0);
        FastClick(Mouse_Left);
        Wait(600);
      End
      Else
      Begin
         // Gametab(Tab_Equip);
          Wait(300);

        If FindDTM(Staff, X, Y, TabBackpack.GetBounds) Then
          Writeln('Staff is equipped') Else
          Begin
            Writeln('Couldnt find staff, cant use this option');
            F33DTM;
            Players[CurrentPlayer].Logout;
            TerminateScript;
          End;
      End;
    End;
  End;      }

  Case Method Of
    0: Begin Writeln('I see you are banking your junk, good luck!'); End;
    1: Begin  Writeln('You are using the drop only method...get that xp!'); End;
    2: Begin Writeln('You are using the alching method...goodbye gold'); End;
    3: Begin Writeln('You are using the superheating and banking method..You are a boss'); End;
    4: Begin Writeln('You are using the superheating and dropping method...What a waste!'); End;
  End;

 // SummoningRenew(PTS,True);

  If Debug Then
    FunctionStop:= 'Setup: Finished';
End;

Begin
  Setup;
  Repeat
    Wait(Random(100));
    If Not POSDebug Then
    Begin
      Mainloop;
    End Else
      Begin
        SPS.DebugPlayerPos;
      End;
    If Not IsLoggedIn Then
    Begin
      If Not IsLoggedIn Then
      Begin
        Players[CurrentPlayer].Login;
        Wait(RandomRange(4000,5000));
        Minimap.ClickCompass;
        MainScreen.SetAngle(MS_ANGLE_HIGH);
       { If UsingFamiliar Then
          SummoningTimer:=(GetSystemTime-((NewPouch-GetNPCTimer)*60*1000)) Else
          NoFamiliar:=True; }
      End;
    End;
  Until Players.GetActive()=0;
End.
